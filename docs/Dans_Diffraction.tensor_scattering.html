<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module Dans_Diffraction.tensor_scattering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="Dans_Diffraction.html"><font color="#ffffff">Dans_Diffraction</font></a>.tensor_scattering</strong></big></big> (version 1.0)</font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Cdgpor%5Conedrive%20-%20diamond%20light%20source%20ltd%5Cpythonprojects%5Cdans_diffraction%5Cdans_diffraction%5Ctensor_scattering.py">c:\users\dgpor\onedrive - diamond light source ltd\pythonprojects\dans_diffraction\dans_diffraction\tensor_scattering.py</a></font></td></tr></table>
    <p><tt>Tensor&nbsp;Scattering&nbsp;code,&nbsp;By&nbsp;Prof.&nbsp;Steve&nbsp;Collins<br>
Based&nbsp;on&nbsp;code&nbsp;available&nbsp;at:&nbsp;https://github.com/spc93/tensor-scattering-calculation<br>
&nbsp;<br>
Example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;xtl&nbsp;=&nbsp;dif.Crystal('ZnO.cif')<br>
&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;<a href="#TensorScatteringClass">TensorScatteringClass</a>(xtl,&nbsp;Site='Zn1',&nbsp;TimeEven=False)<br>
&nbsp;&nbsp;&nbsp;&nbsp;t.PlotIntensityInPolarizationChannels('E1E2',&nbsp;lam=12.4/9.659,&nbsp;hkl=np.array([1,1,5]),&nbsp;hkln=np.array([1,0,0]),&nbsp;K=3,&nbsp;Time=1,&nbsp;Parity=-1,&nbsp;mk=None,&nbsp;sk=None,&nbsp;sigmapi='sigma')<br>
&nbsp;&nbsp;&nbsp;&nbsp;t.<a href="#-print_tensors">print_tensors</a>()<br>
&nbsp;<br>
Created&nbsp;from&nbsp;python&nbsp;package&nbsp;"<a href="#TensorScatteringClass">TensorScatteringClass</a>.py"<br>
Version&nbsp;1.0<br>
17/02/2020<br>
&nbsp;<br>
&nbsp;Proffesor&nbsp;Steve&nbsp;Collins,&nbsp;steve.collins@diamond.ac.uk&nbsp;Tel:&nbsp;+44&nbsp;1235&nbsp;778087<br>
&nbsp;www.diamond.ac.uk<br>
&nbsp;Diamond&nbsp;Light&nbsp;Source,&nbsp;Chilton,&nbsp;Didcot,&nbsp;Oxon,&nbsp;OX11&nbsp;0DE,&nbsp;U.K.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="numpy.html">numpy</a><br>
</td><td width="25%" valign=top><a href="matplotlib.pyplot.html">matplotlib.pyplot</a><br>
</td><td width="25%" valign=top><a href="pprint.html">pprint</a><br>
</td><td width="25%" valign=top><a href="sys.html">sys</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClass">TensorScatteringClass</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClassMagrotExtension">TensorScatteringClassMagrotExtension</a>
</font></dt></dl>
</dd>
</dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="TensorScatteringClass">class <strong>TensorScatteringClass</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#TensorScatteringClass">TensorScatteringClass</a>(xtl,&nbsp;Site,&nbsp;TimeEven=False)<br>
&nbsp;<br>
Python&nbsp;class&nbsp;for&nbsp;resonant&nbsp;tensor&nbsp;scattering.<br>
&nbsp;<br>
xtl&nbsp;=&nbsp;dif.Crystal('ZnO.cif')<br>
t&nbsp;=&nbsp;<a href="#TensorScatteringClass">TensorScatteringClass</a>(xtl,&nbsp;Site='Zn1',&nbsp;TimeEven=False)<br>
t.<a href="#TensorScatteringClass-PlotIntensityInPolarizationChannels">PlotIntensityInPolarizationChannels</a>('E1E2',&nbsp;lam=12.4/9.659,&nbsp;hkl=np.array([1,1,5]),&nbsp;hkln=np.array([1,0,0]),&nbsp;K=3,&nbsp;Time=1,&nbsp;Parity=-1,&nbsp;mk=None,&nbsp;sk=None,&nbsp;sigmapi='sigma')<br>
print(t.<a href="#TensorScatteringClass-print_tensors">print_tensors</a>())<br>
&nbsp;<br>
While&nbsp;this&nbsp;currently&nbsp;has&nbsp;limited&nbsp;capability&nbsp;for&nbsp;magnetic&nbsp;systems,&nbsp;magnetic&nbsp;symmetry&nbsp;operators&nbsp;are&nbsp;used&nbsp;throughout<br>
If&nbsp;no&nbsp;Site&nbsp;keyword&nbsp;arg&nbsp;supplied&nbsp;then&nbsp;available&nbsp;sites&nbsp;will&nbsp;be&nbsp;displayed&nbsp;before&nbsp;exiting<br>
Useful&nbsp;methods:<br>
&nbsp;&nbsp;&nbsp;&nbsp;latt2b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute&nbsp;reciprocal&nbsp;or&nbsp;real-space&nbsp;B&nbsp;matrix&nbsp;from&nbsp;lattice<br>
&nbsp;&nbsp;&nbsp;&nbsp;equiv_sites&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute&nbsp;symmetry-equivalent&nbsp;sites&nbsp;for&nbsp;selected&nbsp;site<br>
&nbsp;&nbsp;&nbsp;&nbsp;invert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverts&nbsp;current&nbsp;spacegroup&nbsp;operators&nbsp;and&nbsp;sites<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#-isGroup">isGroup</a>(sg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns&nbsp;True&nbsp;if&nbsp;sg&nbsp;forms&nbsp;a&nbsp;group&nbsp;or&nbsp;False&nbsp;and&nbsp;shows&nbsp;message&nbsp;if&nbsp;not&nbsp;(self.isGroup(self.<strong>sglist</strong>)&nbsp;should&nbsp;return&nbsp;True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;TensorCalc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate&nbsp;tensor&nbsp;properties&nbsp;for&nbsp;crystal&nbsp;and&nbsp;reflection;&nbsp;save&nbsp;tensors&nbsp;as&nbsp;attributes;&nbsp;print&nbsp;tensor&nbsp;information<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TensorScatteringClass-print_tensors">print_tensors</a>()&nbsp;Display&nbsp;crystal/atomic/structure&nbsp;factor&nbsp;spherical/Cartesian&nbsp;tensors<br>
&nbsp;&nbsp;&nbsp;&nbsp;CalculateIntensityInPolarizationChannels&nbsp;&nbsp;&nbsp;&nbsp;calculate&nbsp;four&nbsp;intensity&nbsp;channels&nbsp;vs&nbsp;psi<br>
&nbsp;&nbsp;&nbsp;&nbsp;PlotIntensityInPolarizationChannels&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot&nbsp;sigma&nbsp;or&nbsp;pi&nbsp;intensity&nbsp;vs&nbsp;azimuthal&nbsp;angle<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
Useful&nbsp;parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;lattice<br>
&nbsp;&nbsp;&nbsp;&nbsp;B<br>
&nbsp;&nbsp;&nbsp;&nbsp;sglist<br>
&nbsp;&nbsp;&nbsp;&nbsp;pglist<br>
&nbsp;&nbsp;&nbsp;&nbsp;crystalpglist<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ts_crystal,&nbsp;Ts_atom,&nbsp;Fs&nbsp;(spherical&nbsp;tensors)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Tc_crystal,&nbsp;Tc_atom,&nbsp;Fc&nbsp;(spherical&nbsp;tensors)<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="TensorScatteringClass-CalculateIntensityFromPolarizationAnalyser"><strong>CalculateIntensityFromPolarizationAnalyser</strong></a>(self, process, lam, hkl, hkln, psideg, pol_eta_deg, pol_th_deg=45, stokesvec_swl=[0, 0, 1], K=None, Time=None, Parity=None, mk=None, lk=None, sk=None)</dt><dd><tt>process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Calculate&nbsp;intensity&nbsp;from&nbsp;polarization&nbsp;analyser&nbsp;vs&nbsp;pol_eta&nbsp;(analyser&nbsp;rotation)<br>
pol_eta_deg&nbsp;can&nbsp;be&nbsp;a&nbsp;scalar&nbsp;or&nbsp;array/list<br>
pol_th_deg&nbsp;is&nbsp;polarizer&nbsp;theta&nbsp;angle&nbsp;(deg)&nbsp;(default&nbsp;45)<br>
stokesvec_swl&nbsp;is&nbsp;Stokes&nbsp;as&nbsp;per&nbsp;SWL&nbsp;papers&nbsp;(P3&nbsp;=&nbsp;horizontal&nbsp;linear,&nbsp;default&nbsp;[0&nbsp;,0,&nbsp;1])</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-CalculateIntensityInPolarizationChannels"><strong>CalculateIntensityInPolarizationChannels</strong></a>(self, process, lam, hkl, hkln, psideg, K=None, Time=None, Parity=None, mk=None, lk=None, sk=None)</dt><dd><tt>process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Calculate&nbsp;intensity&nbsp;in&nbsp;four&nbsp;linear&nbsp;polarization&nbsp;channels<br>
psi&nbsp;can&nbsp;be&nbsp;a&nbsp;scalar&nbsp;or&nbsp;array/list</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-PlotIntensityInPolarizationChannels"><strong>PlotIntensityInPolarizationChannels</strong></a>(self, process, lam, hkl, hkln, psideg=None, K=None, Time=None, Parity=None, mk=None, lk=None, sk=None, sigmapi=None, savefile=None)</dt><dd><tt>Plot&nbsp;azimuthal&nbsp;dependence&nbsp;of&nbsp;sigma&nbsp;or&nbsp;pi&nbsp;intensity&nbsp;and&nbsp;save&nbsp;figure&nbsp;if&nbsp;savefile&nbsp;keyword&nbsp;string&nbsp;(fine&nbsp;name&nbsp;root)&nbsp;given</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-PlotIntensityVsPolarizationAnalyserRotation"><strong>PlotIntensityVsPolarizationAnalyserRotation</strong></a>(self, process, lam, hkl, hkln, psideg, pol_eta_deg, pol_th_deg=45, stokesvec_swl=[0, 0, 1], K=None, Time=None, Parity=None, mk=None, lk=None, sk=None, savefile=None)</dt><dd><tt>Plot&nbsp;intensity&nbsp;vs&nbsp;PA&nbsp;rotation&nbsp;and&nbsp;save&nbsp;figure&nbsp;if&nbsp;savefile&nbsp;keyword&nbsp;string&nbsp;(fine&nbsp;name&nbsp;root)&nbsp;given</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-TensorCalc"><strong>TensorCalc</strong></a>(self, hkl=array([0, 0, 0]), K=None, Parity=1, Time=1)</dt><dd><tt>hkl,&nbsp;hkln:&nbsp;&nbsp;&nbsp;hkl&nbsp;values&nbsp;for&nbsp;reflection&nbsp;and&nbsp;azimuthal&nbsp;reference<br>
returns:&nbsp;Ts,&nbsp;Tc1,&nbsp;Tc_atom,&nbsp;Tc_crystal,&nbsp;Ts_atom,&nbsp;Ts_crystal,&nbsp;Fc,&nbsp;Fs<br>
Ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calcualted&nbsp;spherical&nbsp;tensor<br>
Tc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculated&nbsp;cartesian&nbsp;tensor<br>
Tc_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;cartesian&nbsp;tensor<br>
Tc_crystal&nbsp;&nbsp;Crystal&nbsp;cartesian&nbsp;tensor<br>
Ts_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;spherical&nbsp;tensor<br>
Ts_crystal&nbsp;&nbsp;Crystal&nbsp;spherical&nbsp;tensor<br>
Fc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;Crystal&nbsp;tensor<br>
Fs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;spherical&nbsp;tensor</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-__init__"><strong>__init__</strong></a>(self, xtl, Site, TimeEven=False)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-info"><strong>info</strong></a>(self)</dt></dl>

<dl><dt><a name="TensorScatteringClass-invert"><strong>invert</strong></a>(self)</dt><dd><tt>self.<a href="#TensorScatteringClass-invert">invert</a>()<br>
inverts&nbsp;current&nbsp;spacegroup&nbsp;operators&nbsp;and&nbsp;sites</tt></dd></dl>

<dl><dt><a name="TensorScatteringClass-print_tensors"><strong>print_tensors</strong></a>(self)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="TensorScatteringClassMagrotExtension">class <strong>TensorScatteringClassMagrotExtension</strong></a>(<a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClass">TensorScatteringClass</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#TensorScatteringClassMagrotExtension">TensorScatteringClassMagrotExtension</a>(xtl,&nbsp;Site,&nbsp;TimeEven=False)<br>
&nbsp;<br>
Python&nbsp;class&nbsp;for&nbsp;resonant&nbsp;tensor&nbsp;scattering.<br>
&nbsp;<br>
xtl&nbsp;=&nbsp;dif.Crystal('ZnO.cif')<br>
t&nbsp;=&nbsp;<a href="#TensorScatteringClass">TensorScatteringClass</a>(xtl,&nbsp;Site='Zn1',&nbsp;TimeEven=False)<br>
t.<a href="#TensorScatteringClassMagrotExtension-PlotIntensityInPolarizationChannels">PlotIntensityInPolarizationChannels</a>('E1E2',&nbsp;lam=12.4/9.659,&nbsp;hkl=np.array([1,1,5]),&nbsp;hkln=np.array([1,0,0]),&nbsp;K=3,&nbsp;Time=1,&nbsp;Parity=-1,&nbsp;mk=None,&nbsp;sk=None,&nbsp;sigmapi='sigma')<br>
print(t.<a href="#TensorScatteringClassMagrotExtension-print_tensors">print_tensors</a>())<br>
&nbsp;<br>
While&nbsp;this&nbsp;currently&nbsp;has&nbsp;limited&nbsp;capability&nbsp;for&nbsp;magnetic&nbsp;systems,&nbsp;magnetic&nbsp;symmetry&nbsp;operators&nbsp;are&nbsp;used&nbsp;throughout<br>
If&nbsp;no&nbsp;Site&nbsp;keyword&nbsp;arg&nbsp;supplied&nbsp;then&nbsp;available&nbsp;sites&nbsp;will&nbsp;be&nbsp;displayed&nbsp;before&nbsp;exiting<br>
Useful&nbsp;methods:<br>
&nbsp;&nbsp;&nbsp;&nbsp;latt2b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute&nbsp;reciprocal&nbsp;or&nbsp;real-space&nbsp;B&nbsp;matrix&nbsp;from&nbsp;lattice<br>
&nbsp;&nbsp;&nbsp;&nbsp;equiv_sites&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compute&nbsp;symmetry-equivalent&nbsp;sites&nbsp;for&nbsp;selected&nbsp;site<br>
&nbsp;&nbsp;&nbsp;&nbsp;invert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverts&nbsp;current&nbsp;spacegroup&nbsp;operators&nbsp;and&nbsp;sites<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#-isGroup">isGroup</a>(sg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns&nbsp;True&nbsp;if&nbsp;sg&nbsp;forms&nbsp;a&nbsp;group&nbsp;or&nbsp;False&nbsp;and&nbsp;shows&nbsp;message&nbsp;if&nbsp;not&nbsp;(self.isGroup(self.<strong>sglist</strong>)&nbsp;should&nbsp;return&nbsp;True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;TensorCalc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate&nbsp;tensor&nbsp;properties&nbsp;for&nbsp;crystal&nbsp;and&nbsp;reflection;&nbsp;save&nbsp;tensors&nbsp;as&nbsp;attributes;&nbsp;print&nbsp;tensor&nbsp;information<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TensorScatteringClassMagrotExtension-print_tensors">print_tensors</a>()&nbsp;Display&nbsp;crystal/atomic/structure&nbsp;factor&nbsp;spherical/Cartesian&nbsp;tensors<br>
&nbsp;&nbsp;&nbsp;&nbsp;CalculateIntensityInPolarizationChannels&nbsp;&nbsp;&nbsp;&nbsp;calculate&nbsp;four&nbsp;intensity&nbsp;channels&nbsp;vs&nbsp;psi<br>
&nbsp;&nbsp;&nbsp;&nbsp;PlotIntensityInPolarizationChannels&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot&nbsp;sigma&nbsp;or&nbsp;pi&nbsp;intensity&nbsp;vs&nbsp;azimuthal&nbsp;angle<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
Useful&nbsp;parameters:<br>
&nbsp;&nbsp;&nbsp;&nbsp;lattice<br>
&nbsp;&nbsp;&nbsp;&nbsp;B<br>
&nbsp;&nbsp;&nbsp;&nbsp;sglist<br>
&nbsp;&nbsp;&nbsp;&nbsp;pglist<br>
&nbsp;&nbsp;&nbsp;&nbsp;crystalpglist<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ts_crystal,&nbsp;Ts_atom,&nbsp;Fs&nbsp;(spherical&nbsp;tensors)<br>
&nbsp;&nbsp;&nbsp;&nbsp;Tc_crystal,&nbsp;Tc_atom,&nbsp;Fc&nbsp;(spherical&nbsp;tensors)<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClassMagrotExtension">TensorScatteringClassMagrotExtension</a></dd>
<dd><a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClass">TensorScatteringClass</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="TensorScatteringClassMagrotExtension-PlotIntensityInPolarizationChannelsVsMagrot"><strong>PlotIntensityInPolarizationChannelsVsMagrot</strong></a>(self, process, lam, hkl, hkln, psideg=None, K=None, Time=None, Parity=None, mk=None, lk=None, sk=None, sigmapi=None, savefile=None)</dt><dd><tt>Extension&nbsp;of&nbsp;<a href="#TensorScatteringClass">TensorScatteringClass</a>&nbsp;with&nbsp;new&nbsp;method&nbsp;to&nbsp;calculate&nbsp;magnetic&nbsp;scattering&nbsp;vs&nbsp;magnet&nbsp;rotation&nbsp;angle<br>
Moments&nbsp;are&nbsp;rotated&nbsp;about&nbsp;z&nbsp;axis<br>
psideg&nbsp;must&nbsp;be&nbsp;a&nbsp;scalar<br>
Plot&nbsp;magrot&nbsp;dependence&nbsp;of&nbsp;sigma&nbsp;or&nbsp;pi&nbsp;intensity&nbsp;and&nbsp;save&nbsp;figure&nbsp;if&nbsp;savefile&nbsp;keyword&nbsp;string&nbsp;(fine&nbsp;name&nbsp;root)&nbsp;given</tt></dd></dl>

<hr>
Methods inherited from <a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClass">TensorScatteringClass</a>:<br>
<dl><dt><a name="TensorScatteringClassMagrotExtension-CalculateIntensityFromPolarizationAnalyser"><strong>CalculateIntensityFromPolarizationAnalyser</strong></a>(self, process, lam, hkl, hkln, psideg, pol_eta_deg, pol_th_deg=45, stokesvec_swl=[0, 0, 1], K=None, Time=None, Parity=None, mk=None, lk=None, sk=None)</dt><dd><tt>process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Calculate&nbsp;intensity&nbsp;from&nbsp;polarization&nbsp;analyser&nbsp;vs&nbsp;pol_eta&nbsp;(analyser&nbsp;rotation)<br>
pol_eta_deg&nbsp;can&nbsp;be&nbsp;a&nbsp;scalar&nbsp;or&nbsp;array/list<br>
pol_th_deg&nbsp;is&nbsp;polarizer&nbsp;theta&nbsp;angle&nbsp;(deg)&nbsp;(default&nbsp;45)<br>
stokesvec_swl&nbsp;is&nbsp;Stokes&nbsp;as&nbsp;per&nbsp;SWL&nbsp;papers&nbsp;(P3&nbsp;=&nbsp;horizontal&nbsp;linear,&nbsp;default&nbsp;[0&nbsp;,0,&nbsp;1])</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-CalculateIntensityInPolarizationChannels"><strong>CalculateIntensityInPolarizationChannels</strong></a>(self, process, lam, hkl, hkln, psideg, K=None, Time=None, Parity=None, mk=None, lk=None, sk=None)</dt><dd><tt>process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Calculate&nbsp;intensity&nbsp;in&nbsp;four&nbsp;linear&nbsp;polarization&nbsp;channels<br>
psi&nbsp;can&nbsp;be&nbsp;a&nbsp;scalar&nbsp;or&nbsp;array/list</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-PlotIntensityInPolarizationChannels"><strong>PlotIntensityInPolarizationChannels</strong></a>(self, process, lam, hkl, hkln, psideg=None, K=None, Time=None, Parity=None, mk=None, lk=None, sk=None, sigmapi=None, savefile=None)</dt><dd><tt>Plot&nbsp;azimuthal&nbsp;dependence&nbsp;of&nbsp;sigma&nbsp;or&nbsp;pi&nbsp;intensity&nbsp;and&nbsp;save&nbsp;figure&nbsp;if&nbsp;savefile&nbsp;keyword&nbsp;string&nbsp;(fine&nbsp;name&nbsp;root)&nbsp;given</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-PlotIntensityVsPolarizationAnalyserRotation"><strong>PlotIntensityVsPolarizationAnalyserRotation</strong></a>(self, process, lam, hkl, hkln, psideg, pol_eta_deg, pol_th_deg=45, stokesvec_swl=[0, 0, 1], K=None, Time=None, Parity=None, mk=None, lk=None, sk=None, savefile=None)</dt><dd><tt>Plot&nbsp;intensity&nbsp;vs&nbsp;PA&nbsp;rotation&nbsp;and&nbsp;save&nbsp;figure&nbsp;if&nbsp;savefile&nbsp;keyword&nbsp;string&nbsp;(fine&nbsp;name&nbsp;root)&nbsp;given</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-TensorCalc"><strong>TensorCalc</strong></a>(self, hkl=array([0, 0, 0]), K=None, Parity=1, Time=1)</dt><dd><tt>hkl,&nbsp;hkln:&nbsp;&nbsp;&nbsp;hkl&nbsp;values&nbsp;for&nbsp;reflection&nbsp;and&nbsp;azimuthal&nbsp;reference<br>
returns:&nbsp;Ts,&nbsp;Tc1,&nbsp;Tc_atom,&nbsp;Tc_crystal,&nbsp;Ts_atom,&nbsp;Ts_crystal,&nbsp;Fc,&nbsp;Fs<br>
Ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calcualted&nbsp;spherical&nbsp;tensor<br>
Tc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculated&nbsp;cartesian&nbsp;tensor<br>
Tc_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;cartesian&nbsp;tensor<br>
Tc_crystal&nbsp;&nbsp;Crystal&nbsp;cartesian&nbsp;tensor<br>
Ts_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;spherical&nbsp;tensor<br>
Ts_crystal&nbsp;&nbsp;Crystal&nbsp;spherical&nbsp;tensor<br>
Fc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;Crystal&nbsp;tensor<br>
Fs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;spherical&nbsp;tensor</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-__init__"><strong>__init__</strong></a>(self, xtl, Site, TimeEven=False)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-info"><strong>info</strong></a>(self)</dt></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-invert"><strong>invert</strong></a>(self)</dt><dd><tt>self.<a href="#TensorScatteringClassMagrotExtension-invert">invert</a>()<br>
inverts&nbsp;current&nbsp;spacegroup&nbsp;operators&nbsp;and&nbsp;sites</tt></dd></dl>

<dl><dt><a name="TensorScatteringClassMagrotExtension-print_tensors"><strong>print_tensors</strong></a>(self)</dt></dl>

<hr>
Data descriptors inherited from <a href="Dans_Diffraction.tensor_scattering.html#TensorScatteringClass">TensorScatteringClass</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-CalculateIntensityFromPolarizationAnalyser"><strong>CalculateIntensityFromPolarizationAnalyser</strong></a>(process, B, sitevec, sglist, lam, hkl, hkln, psideg, pol_eta_deg, pol_th_deg=45, stokesvec_swl=[0, 0, 1], K=None, Time=None, Parity=None, mk=None, lk=None, sk=None)</dt><dd><tt>process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Calculate&nbsp;intensity&nbsp;from&nbsp;polarization&nbsp;analyser&nbsp;vs&nbsp;pol_eta&nbsp;(analyser&nbsp;rotation)<br>
pol_eta_deg&nbsp;can&nbsp;be&nbsp;a&nbsp;scalar&nbsp;or&nbsp;array/list<br>
pol_th_deg&nbsp;is&nbsp;polarizer&nbsp;theta&nbsp;angle&nbsp;(deg)&nbsp;(default&nbsp;45)<br>
stokesvec_swl&nbsp;is&nbsp;Stokes&nbsp;as&nbsp;per&nbsp;SWL&nbsp;papers&nbsp;(P3&nbsp;=&nbsp;horizontal&nbsp;linear,&nbsp;default&nbsp;[0&nbsp;,0,&nbsp;1])</tt></dd></dl>
 <dl><dt><a name="-CalculateIntensityInPolarizationChannels"><strong>CalculateIntensityInPolarizationChannels</strong></a>(process, B, sitevec, sglist, lam, hkl, hkln, psideg, K=None, Time=None, Parity=None, mk=None, lk=None, sk=None)</dt><dd><tt>process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Calculate&nbsp;intensity&nbsp;in&nbsp;four&nbsp;linear&nbsp;polarization&nbsp;channels<br>
psi&nbsp;can&nbsp;be&nbsp;a&nbsp;scalar&nbsp;or&nbsp;array/list</tt></dd></dl>
 <dl><dt><a name="-ClebschGordan"><strong>ClebschGordan</strong></a>(j1, j2, m1, m2, J, M, warn=True)</dt><dd><tt><a href="#-ClebschGordan">ClebschGordan</a>(j1,&nbsp;j2,&nbsp;m1,&nbsp;m2,&nbsp;J,&nbsp;M,&nbsp;cglimit=20,warn=True)<br>
Computes&nbsp;exact&nbsp;sympy&nbsp;form&nbsp;for&nbsp;Clebsch-Gordan&nbsp;coefficient<br>
&lt;j1&nbsp;j2;&nbsp;m1&nbsp;m2|j1&nbsp;j2;&nbsp;JM&gt;.<br>
For&nbsp;reference&nbsp;see<br>
<a href="http://en.wikipedia.org/wiki/Table_of_Clebsch-Gordan_coefficients">http://en.wikipedia.org/wiki/Table_of_Clebsch-Gordan_coefficients</a>.<br>
Clebsch&nbsp;Gordan&nbsp;numpy&nbsp;function&nbsp;by&nbsp;Michael&nbsp;V.&nbsp;DePalatis,&nbsp;modified&nbsp;and&nbsp;converted&nbsp;to&nbsp;sympy&nbsp;by&nbsp;SPC<br>
warn&nbsp;gives&nbsp;warning&nbsp;for&nbsp;unphysical&nbsp;coefficients<br>
&nbsp;Adapted&nbsp;from&nbsp;sympy&nbsp;ClebschGordan</tt></dd></dl>
 <dl><dt><a name="-E1E1ResonantMagneticScatteringMatrix"><strong>E1E1ResonantMagneticScatteringMatrix</strong></a>(mk, esig_c, e0pi_c, e1pi_c, q0_c, q1_c)</dt><dd><tt>Calculate&nbsp;2x2&nbsp;scattering&nbsp;amplitude&nbsp;matrix&nbsp;for&nbsp;E1E1&nbsp;resonant&nbsp;magnetic&nbsp;scattering</tt></dd></dl>
 <dl><dt><a name="-NonResonantMagneticScatteringMatrix"><strong>NonResonantMagneticScatteringMatrix</strong></a>(sk, lk, esig_c, e0pi_c, e1pi_c, q0_c, q1_c)</dt><dd><tt>Calculate&nbsp;2x2&nbsp;scattering&nbsp;amplitude&nbsp;matrix&nbsp;for&nbsp;non-resonant&nbsp;magnetic&nbsp;scattering<br>
spin&nbsp;and&nbsp;orbital&nbsp;components&nbsp;(Complex)&nbsp;for&nbsp;reflection&nbsp;are&nbsp;sk,&nbsp;lk<br>
BB&nbsp;and&nbsp;AA&nbsp;are&nbsp;B&nbsp;(spin)&nbsp;and&nbsp;A&nbsp;(orbit)&nbsp;coupling&nbsp;vectors&nbsp;from&nbsp;SWL,&nbsp;Blume&nbsp;etc</tt></dd></dl>
 <dl><dt><a name="-StoneCoefficients"><strong>StoneCoefficients</strong></a>(CouplingSequenceList, k=(-0-1j))</dt><dd><tt><a href="#-StoneCoefficients">StoneCoefficients</a>(CouplingSequenceList,k=phase_convention)<br>
Sympy&nbsp;Spherical-Cartesian&nbsp;conversion&nbsp;coefficients&nbsp;from<br>
A.J.&nbsp;Stone&nbsp;Molecular&nbsp;Physics&nbsp;29&nbsp;1461&nbsp;(1975)&nbsp;(Equation&nbsp;1.9)<br>
CouplingSequenceList&nbsp;is&nbsp;the&nbsp;coupling&nbsp;sequence&nbsp;for&nbsp;spherical&nbsp;tensors,<br>
&nbsp;&nbsp;&nbsp;&nbsp;each&nbsp;time&nbsp;coupling&nbsp;to&nbsp;a&nbsp;new&nbsp;vector&nbsp;to&nbsp;form&nbsp;a&nbsp;tensor&nbsp;of&nbsp;given&nbsp;rank<br>
&nbsp;&nbsp;&nbsp;&nbsp;(sequence&nbsp;always&nbsp;starts&nbsp;with&nbsp;1)<br>
k=-I&nbsp;for&nbsp;Condon&nbsp;&amp;&nbsp;Shortley&nbsp;phase&nbsp;convention&nbsp;(default)&nbsp;of&nbsp;k=1&nbsp;for&nbsp;Racah<br>
e.g.&nbsp;<a href="#-StoneCoefficients">StoneCoefficients</a>([1,2,3])&nbsp;returns&nbsp;conversion&nbsp;coefficients&nbsp;for&nbsp;K=3,&nbsp;coupling&nbsp;with<br>
maximum&nbsp;rank&nbsp;and&nbsp;Condon&nbsp;&amp;&nbsp;Shortley&nbsp;(default)&nbsp;phase&nbsp;convention<br>
Example:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C123=<a href="#-StoneCoefficients">StoneCoefficients</a>([1,2,3])&nbsp;&nbsp;&nbsp;&nbsp;returns&nbsp;conversion&nbsp;matrix&nbsp;for&nbsp;coupling&nbsp;sequence&nbsp;123&nbsp;(K=3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(lcontract(C123,3,[1,0,0,0,0,0,0]))&nbsp;returns&nbsp;table&nbsp;values&nbsp;for&nbsp;Q=-3<br>
Numpy&nbsp;version&nbsp;converted&nbsp;from,&nbsp;Sympy&nbsp;version</tt></dd></dl>
 <dl><dt><a name="-StoneCoupleVector"><strong>StoneCoupleVector</strong></a>(Cold, Knew, C1)</dt><dd><tt><a href="#-StoneCoupleVector">StoneCoupleVector</a>(Cold,Knew,C1)<br>
couple&nbsp;Stone&nbsp;coefficients&nbsp;Cold&nbsp;to&nbsp;a&nbsp;new&nbsp;vector&nbsp;to&nbsp;make&nbsp;coefficient&nbsp;for&nbsp;spherocal&nbsp;tensor&nbsp;of&nbsp;rank&nbsp;Knew<br>
using&nbsp;vector&nbsp;coupling&nbsp;coefficients&nbsp;C1<br>
A.J.&nbsp;Stone&nbsp;Molecular&nbsp;Physics&nbsp;29&nbsp;1461&nbsp;(1975)&nbsp;(Equation&nbsp;1.9)<br>
Numpy&nbsp;version&nbsp;converted&nbsp;from&nbsp;Sympy&nbsp;version</tt></dd></dl>
 <dl><dt><a name="-StoneSphericalToCartConversionCoefs"><strong>StoneSphericalToCartConversionCoefs</strong></a>(K, Calc=True, k=(-0-1j))</dt><dd><tt>Condon&amp;Shortley&nbsp;phase&nbsp;convention&nbsp;(k=-i&nbsp;in&nbsp;Stone's&nbsp;paper)<br>
from&nbsp;FortranForm&nbsp;(No&nbsp;-&nbsp;CForm?)&nbsp;First&nbsp;List-&gt;array,&nbsp;del&nbsp;other&nbsp;lists,spaces,&nbsp;extra&nbsp;bracket&nbsp;around&nbsp;first&nbsp;level<br>
If&nbsp;Calc==False&nbsp;then&nbsp;use&nbsp;these&nbsp;expressions&nbsp;from&nbsp;Mathematica,&nbsp;else&nbsp;calculate&nbsp;them&nbsp;numerically</tt></dd></dl>
 <dl><dt><a name="-TensorScatteringMatrix"><strong>TensorScatteringMatrix</strong></a>(mpol, Fs, time, parity, esig_c, e0pi_c, e1pi_c, q0_c, q1_c)</dt><dd><tt>Calculate&nbsp;2x2&nbsp;scattering&nbsp;amplitude&nbsp;matrix&nbsp;for&nbsp;tensor&nbsp;scattering</tt></dd></dl>
 <dl><dt><a name="-apply_sym"><strong>apply_sym</strong></a>(Tensor, symop_list, Bmat=array([[1, 0, 0],
       [0, 1, 0],
       [0, 0, 1]]), P=None, T=1)</dt><dd><tt>apply&nbsp;point&nbsp;sym&nbsp;ops&nbsp;in&nbsp;symop_list&nbsp;to&nbsp;tensor&nbsp;of&nbsp;rank&nbsp;K<br>
Optional&nbsp;Bmat&nbsp;is&nbsp;used&nbsp;to&nbsp;transform&nbsp;arrays&nbsp;to&nbsp;Cartesian&nbsp;from&nbsp;crystal&nbsp;basis<br>
Default&nbsp;time&nbsp;(T)&nbsp;sym&nbsp;+1;&nbsp;no&nbsp;default&nbsp;for&nbsp;parity&nbsp;(P)</tt></dd></dl>
 <dl><dt><a name="-calc_sf"><strong>calc_sf</strong></a>(Tensor, R, hkl, spacegroup_list, Bmat=array([[1, 0, 0],
       [0, 1, 0],
       [0, 0, 1]]), P=None, T=1)</dt><dd><tt>calc&nbsp;structure&nbsp;factor&nbsp;tensor&nbsp;for&nbsp;symop_list&nbsp;to&nbsp;tensot&nbsp;T&nbsp;of&nbsp;rank&nbsp;K&nbsp;at&nbsp;position&nbsp;R&nbsp;hkl=Q<br>
Optional&nbsp;Bmat&nbsp;is&nbsp;used&nbsp;to&nbsp;transform&nbsp;arrays&nbsp;to&nbsp;Cartesian&nbsp;from&nbsp;crystal&nbsp;basis</tt></dd></dl>
 <dl><dt><a name="-calculatescatteringmatrix"><strong>calculatescatteringmatrix</strong></a>(process, B, lam, psival, hkl, hkln, Fs, Time=None, Parity=None, mk=None, sk=None, lk=None)</dt><dd><tt>Calculate&nbsp;G&nbsp;for&nbsp;specified&nbsp;scattering&nbsp;process;&nbsp;require&nbsp;B,&nbsp;lam,&nbsp;psival,&nbsp;hkl,&nbsp;hkln<br>
process&nbsp;=&nbsp;'Scalar',&nbsp;'E1E1',&nbsp;'E1E2',&nbsp;'E2E2',&nbsp;'E1E1mag',&nbsp;'NonResMag'<br>
Fs&nbsp;(structure&nbsp;factor&nbsp;spherical&nbsp;tensor),&nbsp;Time&nbsp;&amp;&nbsp;Parity&nbsp;symmetry,&nbsp;mk,&nbsp;sk,&nbsp;lk&nbsp;are&nbsp;required&nbsp;for&nbsp;specific&nbsp;processes&nbsp;only<br>
2&nbsp;x&nbsp;2&nbsp;G&nbsp;matrix&nbsp;defined&nbsp;in&nbsp;SWL&nbsp;papers</tt></dd></dl>
 <dl><dt><a name="-calcxrayvectors"><strong>calcxrayvectors</strong></a>(B, lam, psi, hkl, hkln)</dt><dd><tt>calculate&nbsp;relevant&nbsp;Cartesian&nbsp;vector&nbsp;in&nbsp;sample&nbsp;reference&nbsp;frame<br>
return(h,&nbsp;q0,&nbsp;q1,&nbsp;esig,&nbsp;e0pi,&nbsp;e1pi)</tt></dd></dl>
 <dl><dt><a name="-caltheta"><strong>caltheta</strong></a>(B, lam, hkl)</dt><dd><tt>Calculate&nbsp;Bragg&nbsp;angle&nbsp;theta<br>
:param&nbsp;B:&nbsp;B&nbsp;matrix<br>
:param&nbsp;lam:&nbsp;wavelength&nbsp;in&nbsp;A<br>
:param&nbsp;hkl:&nbsp;[hkl]<br>
:return:&nbsp;float:&nbsp;angle&nbsp;in&nbsp;deg</tt></dd></dl>
 <dl><dt><a name="-cart_to_spherical_tensor"><strong>cart_to_spherical_tensor</strong></a>(Tc)</dt></dl>
 <dl><dt><a name="-crystal_point_sym"><strong>crystal_point_sym</strong></a>(spacegroup_list)</dt></dl>
 <dl><dt><a name="-crystal_to_cart_operator"><strong>crystal_to_cart_operator</strong></a>(S, B)</dt></dl>
 <dl><dt><a name="-equiv_sites"><strong>equiv_sites</strong></a>(spacegroup_list, sitevec)</dt><dd><tt><a href="#-equiv_sites">equiv_sites</a>(spacegroup_list,&nbsp;sitevec)<br>
returns&nbsp;symmetry-equivalent&nbsp;sites&nbsp;for&nbsp;selected&nbsp;site</tt></dd></dl>
 <dl><dt><a name="-firstCell"><strong>firstCell</strong></a>(V)</dt></dl>
 <dl><dt><a name="-genpos2matvec"><strong>genpos2matvec</strong></a>(gen_pos_string)</dt><dd><tt>convert&nbsp;general&nbsp;position&nbsp;string&nbsp;to&nbsp;vector/matrix&nbsp;form&nbsp;(floats)&nbsp;using&nbsp;lists&nbsp;as&nbsp;row&nbsp;vectors</tt></dd></dl>
 <dl><dt><a name="-indexlist"><strong>indexlist</strong></a>(shape)</dt><dd><tt><a href="#-indexlist">indexlist</a>(shape)<br>
create&nbsp;a&nbsp;list&nbsp;of&nbsp;index&nbsp;lists&nbsp;covering&nbsp;all&nbsp;indices&nbsp;for&nbsp;shape&nbsp;list&nbsp;(all&nbsp;possible&nbsp;indices)<br>
&nbsp;&nbsp;(Numpy&nbsp;1.6&nbsp;has&nbsp;new&nbsp;indexing&nbsp;functionality&nbsp;that&nbsp;my&nbsp;render&nbsp;this&nbsp;obsolete)</tt></dd></dl>
 <dl><dt><a name="-isGroup"><strong>isGroup</strong></a>(G)</dt><dd><tt>Tests&nbsp;if&nbsp;G&nbsp;is&nbsp;a&nbsp;group<br>
:param&nbsp;G:&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;[mat,&nbsp;vec,&nbsp;timescalar]<br>
:return:&nbsp;Boolean</tt></dd></dl>
 <dl><dt><a name="-latt2b"><strong>latt2b</strong></a>(lat, direct=False, BLstyle=False)</dt><dd><tt>follow&nbsp;Busing&amp;Levy,&nbsp;D.E.Sands<br>
direct=False:&nbsp;normal&nbsp;recip&nbsp;space&nbsp;B&nbsp;matrix&nbsp;(B&amp;L)<br>
direct=True,&nbsp;BLstyle=True:&nbsp;Busing&nbsp;&amp;&nbsp;Levy&nbsp;style&nbsp;applied&nbsp;to&nbsp;real&nbsp;space&nbsp;(i.e.&nbsp;x||a)<br>
direct=True,&nbsp;BLstyle=False:&nbsp;Real&nbsp;space&nbsp;B&nbsp;matrix&nbsp;compatible&nbsp;with&nbsp;recip&nbsp;space&nbsp;B&nbsp;matrix</tt></dd></dl>
 <dl><dt><a name="-msg"><strong>msg</strong></a>(num, txt=['plus', 'minus', 'zero', 'other'])</dt><dd><tt>return&nbsp;message&nbsp;text&nbsp;for&nbsp;+1,-1,&nbsp;0,&nbsp;other&nbsp;(e.g.&nbsp;None)</tt></dd></dl>
 <dl><dt><a name="-norm_array"><strong>norm_array</strong></a>(Array, Minval=0.001)</dt><dd><tt>Normalise&nbsp;array&nbsp;by&nbsp;largest&nbsp;abs&nbsp;value&nbsp;if&nbsp;&gt;Minval&nbsp;(avoids&nbsp;trying&nbsp;to&nbsp;renormalise&nbsp;zero&nbsp;array)</tt></dd></dl>
 <dl><dt><a name="-print_tensors"><strong>print_tensors</strong></a>(B, sitevec, sglist, hkl=array([0, 0, 0]), K=None, Parity=1, Time=1)</dt><dd><tt>return&nbsp;str&nbsp;of&nbsp;tensors</tt></dd></dl>
 <dl><dt><a name="-rand"><strong>rand</strong></a>(...)<font color="#909090"><font face="helvetica, arial"> method of <a href="numpy.random.mtrand.html#RandomState">mtrand.RandomState</a> instance</font></font></dt><dd><tt><a href="#-rand">rand</a>(d0,&nbsp;d1,&nbsp;...,&nbsp;dn)<br>
&nbsp;<br>
Random&nbsp;values&nbsp;in&nbsp;a&nbsp;given&nbsp;shape.<br>
&nbsp;<br>
Create&nbsp;an&nbsp;array&nbsp;of&nbsp;the&nbsp;given&nbsp;shape&nbsp;and&nbsp;populate&nbsp;it&nbsp;with<br>
random&nbsp;samples&nbsp;from&nbsp;a&nbsp;uniform&nbsp;distribution<br>
over&nbsp;``[0,&nbsp;1)``.<br>
&nbsp;<br>
Parameters<br>
----------<br>
d0,&nbsp;d1,&nbsp;...,&nbsp;dn&nbsp;:&nbsp;int,&nbsp;optional<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;dimensions&nbsp;of&nbsp;the&nbsp;returned&nbsp;array,&nbsp;should&nbsp;all&nbsp;be&nbsp;positive.<br>
&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;no&nbsp;argument&nbsp;is&nbsp;given&nbsp;a&nbsp;single&nbsp;Python&nbsp;float&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
Returns<br>
-------<br>
out&nbsp;:&nbsp;ndarray,&nbsp;shape&nbsp;``(d0,&nbsp;d1,&nbsp;...,&nbsp;dn)``<br>
&nbsp;&nbsp;&nbsp;&nbsp;Random&nbsp;values.<br>
&nbsp;<br>
See&nbsp;Also<br>
--------<br>
random<br>
&nbsp;<br>
Notes<br>
-----<br>
This&nbsp;is&nbsp;a&nbsp;convenience&nbsp;function.&nbsp;If&nbsp;you&nbsp;want&nbsp;an&nbsp;interface&nbsp;that<br>
takes&nbsp;a&nbsp;shape-tuple&nbsp;as&nbsp;the&nbsp;first&nbsp;argument,&nbsp;refer&nbsp;to<br>
np.random.random_sample&nbsp;.<br>
&nbsp;<br>
Examples<br>
--------<br>
&gt;&gt;&gt;&nbsp;np.random.<a href="#-rand">rand</a>(3,2)<br>
array([[&nbsp;0.14022471,&nbsp;&nbsp;0.96360618],&nbsp;&nbsp;#random<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.37601032,&nbsp;&nbsp;0.25528411],&nbsp;&nbsp;#random<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;0.49313049,&nbsp;&nbsp;0.94909878]])&nbsp;#random</tt></dd></dl>
 <dl><dt><a name="-scalar_contract"><strong>scalar_contract</strong></a>(X, T)</dt></dl>
 <dl><dt><a name="-sf_symmetry"><strong>sf_symmetry</strong></a>(R, hkl, spacegroup_list)</dt><dd><tt>analyse&nbsp;symmetry&nbsp;of&nbsp;any&nbsp;possible&nbsp;structure&nbsp;factor&nbsp;(mainly&nbsp;for&nbsp;information)<br>
returns&nbsp;[sym_phases,&nbsp;gen_scalar_allowed,&nbsp;site_scalar_allowed,&nbsp;tensor_allowed,&nbsp;Psym,&nbsp;Tsym,&nbsp;PTsym]</tt></dd></dl>
 <dl><dt><a name="-site_sym"><strong>site_sym</strong></a>(spacegroup_list, sitevec)</dt></dl>
 <dl><dt><a name="-spacegroup_list_from_genpos_list"><strong>spacegroup_list_from_genpos_list</strong></a>(genposlist)</dt></dl>
 <dl><dt><a name="-spherical_to_cart_tensor"><strong>spherical_to_cart_tensor</strong></a>(Ts)</dt></dl>
 <dl><dt><a name="-symmetry_str"><strong>symmetry_str</strong></a>(R, hkl, spacegroup_list)</dt><dd><tt>analyse&nbsp;symmetry&nbsp;of&nbsp;any&nbsp;possible&nbsp;structure&nbsp;factor&nbsp;(mainly&nbsp;for&nbsp;information)<br>
returns&nbsp;str</tt></dd></dl>
 <dl><dt><a name="-tensorcalc"><strong>tensorcalc</strong></a>(B, sitevec, sglist, hkl=array([0, 0, 0]), K=None, Parity=1, Time=1)</dt><dd><tt>calculate&nbsp;scatterin&nbsp;tensor<br>
B&nbsp;=&nbsp;B&nbsp;matrix<br>
sitevec&nbsp;=&nbsp;[u,v,w]<br>
sglist&nbsp;=&nbsp;list&nbsp;of&nbsp;symmetries<br>
hkl,&nbsp;hkln:&nbsp;&nbsp;&nbsp;hkl&nbsp;values&nbsp;for&nbsp;reflection&nbsp;and&nbsp;azimuthal&nbsp;reference<br>
K&nbsp;=&nbsp;tensor&nbsp;rank<br>
Parity&nbsp;=&nbsp;+/-&nbsp;1<br>
Time&nbsp;=&nbsp;+/-&nbsp;1<br>
returns:&nbsp;Ts,&nbsp;Tc1,&nbsp;Tc_atom,&nbsp;Tc_crystal,&nbsp;Ts_atom,&nbsp;Ts_crystal,&nbsp;Fc,&nbsp;Fs<br>
Ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calcualted&nbsp;spherical&nbsp;tensor<br>
Tc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculated&nbsp;cartesian&nbsp;tensor<br>
Tc_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;cartesian&nbsp;tensor<br>
Tc_crystal&nbsp;&nbsp;Crystal&nbsp;cartesian&nbsp;tensor<br>
Ts_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;spherical&nbsp;tensor<br>
Ts_crystal&nbsp;&nbsp;Crystal&nbsp;spherical&nbsp;tensor<br>
Fc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;Crystal&nbsp;tensor<br>
Fs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;spherical&nbsp;tensor</tt></dd></dl>
 <dl><dt><a name="-tensorproperties"><strong>tensorproperties</strong></a>(sitevec, sglist, hkl=array([0, 0, 0]), Parity=1, Time=1)</dt><dd><tt>Return&nbsp;tensor&nbsp;properties<br>
sitevec&nbsp;=&nbsp;[u,v,w]<br>
sglist&nbsp;=&nbsp;list&nbsp;of&nbsp;symmetries<br>
hkl,&nbsp;hkln:&nbsp;&nbsp;&nbsp;hkl&nbsp;values&nbsp;for&nbsp;reflection&nbsp;and&nbsp;azimuthal&nbsp;reference<br>
returns:&nbsp;Ts,&nbsp;Tc1,&nbsp;Tc_atom,&nbsp;Tc_crystal,&nbsp;Ts_atom,&nbsp;Ts_crystal,&nbsp;Fc,&nbsp;Fs<br>
Ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calcualted&nbsp;spherical&nbsp;tensor<br>
Tc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculated&nbsp;cartesian&nbsp;tensor<br>
Tc_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;cartesian&nbsp;tensor<br>
Tc_crystal&nbsp;&nbsp;Crystal&nbsp;cartesian&nbsp;tensor<br>
Ts_atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomic&nbsp;spherical&nbsp;tensor<br>
Ts_crystal&nbsp;&nbsp;Crystal&nbsp;spherical&nbsp;tensor<br>
Fc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;Crystal&nbsp;tensor<br>
Fs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SF&nbsp;spherical&nbsp;tensor</tt></dd></dl>
 <dl><dt><a name="-theta_to_cartesian"><strong>theta_to_cartesian</strong></a>(hkl, hkln, psi, B)</dt><dd><tt>Unitary&nbsp;matrix&nbsp;for&nbsp;transformation&nbsp;from&nbsp;theta&nbsp;to&nbsp;cartesian&nbsp;coordinate&nbsp;system</tt></dd></dl>
 <dl><dt><a name="-transform_cart"><strong>transform_cart</strong></a>(T, S, P=0)</dt><dd><tt>#transform&nbsp;Cart&nbsp;tensor&nbsp;rank&nbsp;K&nbsp;using&nbsp;symmetry&nbsp;operator&nbsp;S<br>
#If&nbsp;optional&nbsp;parameter&nbsp;P&nbsp;(parity)&nbsp;is&nbsp;given&nbsp;then&nbsp;a&nbsp;correction&nbsp;is&nbsp;made&nbsp;to&nbsp;account&nbsp;for&nbsp;the&nbsp;otherwise&nbsp;incorrect<br>
#tranformation&nbsp;of&nbsp;Cartesian&nbsp;tensors&nbsp;derived&nbsp;from&nbsp;spherical&nbsp;pseudotensors&nbsp;(see&nbsp;Mittelwihr&nbsp;paper)</tt></dd></dl>
 <dl><dt><a name="-xtensor"><strong>xtensor</strong></a>(process, rank, time, parity, e0, e1, q0, q1)</dt><dd><tt>Calculates&nbsp;resonant&nbsp;scattering&nbsp;tensor&nbsp;as&nbsp;per&nbsp;Lovesey<br>
This&nbsp;version&nbsp;is&nbsp;a&nbsp;dump&nbsp;of&nbsp;the&nbsp;output&nbsp;of&nbsp;a&nbsp;Mathematica&nbsp;implementation&nbsp;(hence&nbsp;messy!)<br>
The&nbsp;Sympy&nbsp;version&nbsp;of&nbsp;this&nbsp;calculation&nbsp;carries&nbsp;out&nbsp;the&nbsp;same&nbsp;tensor&nbsp;calculation</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>FMT</strong> = '<font color="#c040c0">\n</font>%28s:  '</td></tr></table>
</body></html>