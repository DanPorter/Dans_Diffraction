<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module Dans_Diffraction.classes_crystal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="Dans_Diffraction.html"><font color="#ffffff">Dans_Diffraction</font></a>.classes_crystal</strong></big></big> (version 3.2.3)</font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Cdgpor%5Conedrive%20-%20diamond%20light%20source%20ltd%5Cpythonprojects%5Cdans_diffraction%5Cdans_diffraction%5Cclasses_crystal.py">c:\users\dgpor\onedrive - diamond light source ltd\pythonprojects\dans_diffraction\dans_diffraction\classes_crystal.py</a></font></td></tr></table>
    <p><tt>classes_crystal.py<br>
A&nbsp;crystal&nbsp;<a href="builtins.html#object">object</a>&nbsp;that&nbsp;reads&nbsp;crystallogaphic&nbsp;data&nbsp;from&nbsp;cif&nbsp;files&nbsp;and<br>
can&nbsp;generate&nbsp;useful&nbsp;information&nbsp;such&nbsp;as&nbsp;reflection&nbsp;intensities&nbsp;and&nbsp;<br>
two-theta&nbsp;angles.<br>
&nbsp;<br>
E.G.&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;'Folder/Diamond.cif'<br>
&nbsp;&nbsp;&nbsp;&nbsp;xtl&nbsp;=&nbsp;<a href="#Crystal">Crystal</a>(f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;xtl.info()&nbsp;&gt;&gt;&nbsp;print&nbsp;information&nbsp;about&nbsp;the&nbsp;crystal<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Crystal">Crystal</a>&nbsp;properties&nbsp;are&nbsp;stored&nbsp;within&nbsp;lower&nbsp;classes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.<a href="#Cell">Cell</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;lattice&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.<a href="#Symmetry">Symmetry</a>&nbsp;&gt;&gt;&nbsp;<a href="#Symmetry">Symmetry</a>&nbsp;operations<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.<a href="#Atoms">Atoms</a>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;Symmetric&nbsp;atomic&nbsp;positions<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.Structure&gt;&gt;&nbsp;All&nbsp;atomic&nbsp;positions&nbsp;within&nbsp;the&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Additional&nbsp;calculations&nbsp;can&nbsp;be&nbsp;made&nbsp;within&nbsp;additional&nbsp;classes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.Properties&nbsp;&gt;&gt;&nbsp;Calculate&nbsp;and&nbsp;display&nbsp;useful&nbsp;properties<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.Plot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;Plot&nbsp;<a href="#Crystal">Crystal</a>&nbsp;structures&nbsp;and&nbsp;simulate&nbsp;diffraction&nbsp;patterns<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtl.Scatter&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;Simulate&nbsp;diffraction&nbsp;intensities&nbsp;of&nbsp;different&nbsp;types<br>
&nbsp;<br>
By&nbsp;Dan&nbsp;Porter,&nbsp;PhD<br>
Diamond<br>
2017<br>
&nbsp;<br>
Version&nbsp;3.2.3<br>
Last&nbsp;updated:&nbsp;12/01/21<br>
&nbsp;<br>
Version&nbsp;History:<br>
27/07/17&nbsp;1.0&nbsp;&nbsp;&nbsp;&nbsp;Version&nbsp;History&nbsp;started.<br>
30/10/17&nbsp;1.1&nbsp;&nbsp;&nbsp;&nbsp;Many&nbsp;minor&nbsp;updates.<br>
06/01/18&nbsp;2.0&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;change&nbsp;and&nbsp;other&nbsp;updates<br>
13/02/18&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;Move&nbsp;scattering&nbsp;commands&nbsp;to&nbsp;xtl.Scatter<br>
05/04/18&nbsp;2.2&nbsp;&nbsp;&nbsp;&nbsp;Magnetic&nbsp;symmetry&nbsp;automatically&nbsp;inverted&nbsp;for&nbsp;odd&nbsp;time<br>
04/06/18&nbsp;2.3&nbsp;&nbsp;&nbsp;&nbsp;removeatom&nbsp;added&nbsp;to&nbsp;<a href="#Atom">Atom</a>&nbsp;class<br>
31/10/18&nbsp;2.3&nbsp;&nbsp;&nbsp;&nbsp;Update&nbsp;<a href="#Symmetry">Symmetry</a>.symmetric_coordinates&nbsp;funcitons,&nbsp;add&nbsp;ability&nbsp;to&nbsp;view&nbsp;all&nbsp;or&nbsp;only&nbsp;non-identical<br>
09/03/19&nbsp;2.4&nbsp;&nbsp;&nbsp;&nbsp;Add&nbsp;print&nbsp;functions&nbsp;to&nbsp;<a href="#Symmetry">Symmetry</a><br>
12/08/19&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;self.<strong>info</strong>&nbsp;outputs&nbsp;string,&nbsp;__repr__&nbsp;methods&nbsp;added<br>
12/12/19&nbsp;2.6&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;<a href="#Symmetry">Symmetry</a>.is_symmetric_reflection(ref1,&nbsp;ref2),&nbsp;added&nbsp;multiple&nbsp;scattering&nbsp;code<br>
30/03/20&nbsp;2.7&nbsp;&nbsp;&nbsp;&nbsp;Moved&nbsp;Multicrystal&nbsp;class&nbsp;to&nbsp;separate&nbsp;file,&nbsp;other&nbsp;minor&nbsp;tweaks<br>
19/04/20&nbsp;2.8&nbsp;&nbsp;&nbsp;&nbsp;Added&nbsp;update_cif&nbsp;and&nbsp;write_cif&nbsp;funcitons<br>
12/05/20&nbsp;2.9&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;<a href="#Atom">Atom</a>.from_cif&nbsp;to&nbsp;be&nbsp;more&nbsp;reliable<br>
27/05/20&nbsp;3.0&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;write_cif&nbsp;for&nbsp;magnetic&nbsp;moments&nbsp;-&nbsp;now&nbsp;writes&nbsp;simple&nbsp;mcif&nbsp;structures<br>
09/06/20&nbsp;3.0.1&nbsp;&nbsp;Updated&nbsp;code&nbsp;for&nbsp;changes&nbsp;to&nbsp;fc.gen_sym_mat<br>
10/06/20&nbsp;3.1&nbsp;&nbsp;&nbsp;&nbsp;Updated&nbsp;<a href="#Symmetry">Symmetry</a>&nbsp;to&nbsp;include&nbsp;time&nbsp;operators<br>
02/09/20&nbsp;3.2.0&nbsp;&nbsp;Added&nbsp;<a href="#Cell">Cell</a>.reflection_hkl&nbsp;and&nbsp;transmission_hkl,&nbsp;added&nbsp;__str__&nbsp;methods<br>
22/10/20&nbsp;3.2.1&nbsp;&nbsp;Added&nbsp;<a href="#Cell">Cell</a>.moment,&nbsp;updated&nbsp;<a href="#Cell">Cell</a>.latt()<br>
15/11/21&nbsp;3.2.2&nbsp;&nbsp;Added&nbsp;<a href="#Cell">Cell</a>.orientation,&nbsp;updated&nbsp;<a href="#Cell">Cell</a>.UV()<br>
12/01/21&nbsp;3.2.3&nbsp;&nbsp;Added&nbsp;<a href="#Symmetry">Symmetry</a>.axial_vector<br>
&nbsp;<br>
@author:&nbsp;DGPorter</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="Dans_Diffraction.functions_crystallography.html">Dans_Diffraction.functions_crystallography</a><br>
</td><td width="25%" valign=top><a href="Dans_Diffraction.functions_general.html">Dans_Diffraction.functions_general</a><br>
</td><td width="25%" valign=top><a href="numpy.html">numpy</a><br>
</td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="Dans_Diffraction.classes_crystal.html#Atom">Atom</a>
</font></dt><dt><font face="helvetica, arial"><a href="Dans_Diffraction.classes_crystal.html#Atoms">Atoms</a>
</font></dt><dt><font face="helvetica, arial"><a href="Dans_Diffraction.classes_crystal.html#Cell">Cell</a>
</font></dt><dt><font face="helvetica, arial"><a href="Dans_Diffraction.classes_crystal.html#Crystal">Crystal</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="Dans_Diffraction.classes_crystal.html#Superstructure">Superstructure</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="Dans_Diffraction.classes_crystal.html#Symmetry">Symmetry</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Atom">class <strong>Atom</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Atom">Atom</a>(u,&nbsp;v,&nbsp;w,&nbsp;atom_type,&nbsp;label,&nbsp;occupancy=1.0,&nbsp;uiso=0.001,&nbsp;mxmymz=None)<br>
&nbsp;<br>
<a href="#Atom">Atom</a>&nbsp;class<br>
Contains&nbsp;site&nbsp;information<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Atom-__init__"><strong>__init__</strong></a>(self, u, v, w, atom_type, label, occupancy=1.0, uiso=0.001, mxmymz=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Atom-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Atom-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Atom-info"><strong>info</strong></a>(self)</dt><dd><tt>Display&nbsp;atomic&nbsp;properties</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Atoms">class <strong>Atoms</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Atoms">Atoms</a>(u=[0],&nbsp;v=[0],&nbsp;w=[0],&nbsp;type=None,&nbsp;label=None,&nbsp;occupancy=None,&nbsp;uiso=None,&nbsp;mxmymz=None)<br>
&nbsp;<br>
Contains&nbsp;properties&nbsp;of&nbsp;atoms&nbsp;within&nbsp;the&nbsp;crystal<br>
Each&nbsp;atom&nbsp;has&nbsp;properties:<br>
&nbsp;&nbsp;&nbsp;&nbsp;u,v,w&nbsp;&gt;&gt;&nbsp;atomic&nbsp;coordinates,&nbsp;in&nbsp;the&nbsp;basis&nbsp;of&nbsp;the&nbsp;unit&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&gt;&gt;&nbsp;element&nbsp;species,&nbsp;given&nbsp;as&nbsp;element&nbsp;name,&nbsp;e.g.&nbsp;'Fe'<br>
&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;&gt;&gt;&nbsp;Name&nbsp;of&nbsp;atomic&nbsp;position,&nbsp;e.g.&nbsp;'Fe1'<br>
&nbsp;&nbsp;&nbsp;&nbsp;occupancy&nbsp;&gt;&gt;&nbsp;Occupancy&nbsp;of&nbsp;this&nbsp;atom&nbsp;at&nbsp;this&nbsp;atomic&nbsp;position<br>
&nbsp;&nbsp;&nbsp;&nbsp;uiso&nbsp;&gt;&gt;&nbsp;atomic&nbsp;displacement&nbsp;factor&nbsp;(ADP)&nbsp;&lt;u^2&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;mxmymz&nbsp;&gt;&gt;&nbsp;magnetic&nbsp;moment&nbsp;direction&nbsp;[x,y,z]<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Atoms-__call__"><strong>__call__</strong></a>(self, u=[0], v=[0], w=[0], type=None, label=None, occupancy=None, uiso=None, mxmymz=None)</dt><dd><tt>Re-initialises&nbsp;the&nbsp;class,&nbsp;generating&nbsp;new&nbsp;atomic&nbsp;positions</tt></dd></dl>

<dl><dt><a name="Atoms-__getitem__"><strong>__getitem__</strong></a>(self, idx)</dt></dl>

<dl><dt><a name="Atoms-__init__"><strong>__init__</strong></a>(self, u=[0], v=[0], w=[0], type=None, label=None, occupancy=None, uiso=None, mxmymz=None)</dt><dd><tt>Initialisation,&nbsp;defines&nbsp;<a href="#Atoms">Atoms</a>&nbsp;defaults</tt></dd></dl>

<dl><dt><a name="Atoms-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Atoms-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Atoms-addatom"><strong>addatom</strong></a>(self, u=0, v=0, w=0, type=None, label=None, occupancy=None, uiso=None, mxmymz=None)</dt><dd><tt>Adds&nbsp;a&nbsp;new&nbsp;atom<br>
:param&nbsp;u:<br>
:param&nbsp;v:<br>
:param&nbsp;w:<br>
:param&nbsp;type:<br>
:param&nbsp;label:<br>
:param&nbsp;occupancy:<br>
:param&nbsp;uiso:<br>
:param&nbsp;mxmymz:<br>
:return:</tt></dd></dl>

<dl><dt><a name="Atoms-atom"><strong>atom</strong></a>(self, idx)</dt><dd><tt>Create&nbsp;<a href="#Atom">Atom</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;for&nbsp;atom&nbsp;site</tt></dd></dl>

<dl><dt><a name="Atoms-changeatom"><strong>changeatom</strong></a>(self, idx=None, u=None, v=None, w=None, type=None, label=None, occupancy=None, uiso=None, mxmymz=None)</dt><dd><tt>Change&nbsp;an&nbsp;atoms&nbsp;properties<br>
:param&nbsp;idx:<br>
:param&nbsp;u:<br>
:param&nbsp;v:<br>
:param&nbsp;w:<br>
:param&nbsp;type:<br>
:param&nbsp;label:<br>
:param&nbsp;occupancy:<br>
:param&nbsp;uiso:<br>
:param&nbsp;mxmymz:<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Atoms-check"><strong>check</strong></a>(self)</dt><dd><tt>Checks&nbsp;the&nbsp;validity&nbsp;of&nbsp;the&nbsp;contained&nbsp;attributes<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Atoms-findatom"><strong>findatom</strong></a>(self, u=None, v=None, w=None, type=None, label=None, occupancy=None, uiso=None, mxmymz=None, tol=0.01)</dt><dd><tt>Find&nbsp;atom&nbsp;using&nbsp;parameters,&nbsp;return&nbsp;idx<br>
:param&nbsp;u:&nbsp;float<br>
:param&nbsp;v:&nbsp;float<br>
:param&nbsp;w:&nbsp;float<br>
:param&nbsp;type:&nbsp;str<br>
:param&nbsp;label:&nbsp;str<br>
:param&nbsp;occupancy:&nbsp;float<br>
:param&nbsp;uiso:&nbsp;float<br>
:param&nbsp;mxmymz:&nbsp;[mx,my,mz]<br>
:param&nbsp;tol:&nbsp;float,&nbsp;tolerance&nbsp;to&nbsp;match&nbsp;value<br>
:return:&nbsp;array&nbsp;of&nbsp;indexes</tt></dd></dl>

<dl><dt><a name="Atoms-fromcif"><strong>fromcif</strong></a>(self, cifvals)</dt><dd><tt>Import&nbsp;atom&nbsp;parameters&nbsp;from&nbsp;a&nbsp;cif&nbsp;dictionary<br>
Required&nbsp;cif&nbsp;keys:<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_label<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_fract_x<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_fract_y<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_fract_z<br>
Optional&nbsp;cif&nbsp;keys:<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_type_symbol<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_U_iso_or_equiv<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_B_iso_or_equiv<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_occupancy<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_moment_label<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_moment_crystalaxis_x<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_moment_crystalaxis_y<br>
&nbsp;&nbsp;&nbsp;&nbsp;_atom_site_moment_crystalaxis_z<br>
:param&nbsp;cifvals:&nbsp;dict<br>
:return:&nbsp;none</tt></dd></dl>

<dl><dt><a name="Atoms-generate_lattice"><strong>generate_lattice</strong></a>(self, U=1, V=1, W=0, centred=True)</dt><dd><tt>Expand&nbsp;the&nbsp;atomic&nbsp;positions&nbsp;beyond&nbsp;the&nbsp;unit&nbsp;cell,&nbsp;creating&nbsp;a&nbsp;lattice<br>
&nbsp;&nbsp;&nbsp;&nbsp;uvw,type,label,occ,uiso,mxmymz&nbsp;=&nbsp;self.<a href="#Atoms-generate_lattice">generate_lattice</a>(U,V,W,centred)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U,V,W&nbsp;=&nbsp;maximum&nbsp;lattice&nbsp;index&nbsp;to&nbsp;loop&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;centred&nbsp;=&nbsp;if&nbsp;True,&nbsp;positions&nbsp;will&nbsp;loop&nbsp;from&nbsp;e.g.&nbsp;-U&nbsp;to&nbsp;U,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherwise,&nbsp;will&nbsp;loop&nbsp;from&nbsp;e.g.&nbsp;0&nbsp;to&nbsp;U<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uvw,type,label,occ,uiso,mxmymz&nbsp;=&nbsp;standard&nbsp;array&nbsp;outputs&nbsp;of&nbsp;<a href="#Atoms">Atoms</a></tt></dd></dl>

<dl><dt><a name="Atoms-get"><strong>get</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;structure&nbsp;arrays<br>
&nbsp;uvw,&nbsp;type,&nbsp;label,&nbsp;occupancy,&nbsp;uiso,&nbsp;mxmymz&nbsp;=&nbsp;<a href="#Atoms">Atoms</a>.<a href="#Atoms-get">get</a>()</tt></dd></dl>

<dl><dt><a name="Atoms-info"><strong>info</strong></a>(self, idx=None, type=None)</dt><dd><tt>Prints&nbsp;properties&nbsp;of&nbsp;all&nbsp;atoms<br>
:param&nbsp;idx:&nbsp;None&nbsp;or&nbsp;array&nbsp;of&nbsp;atoms&nbsp;to&nbsp;display<br>
:param&nbsp;type:&nbsp;None&nbsp;or&nbsp;str&nbsp;type&nbsp;of&nbsp;atom&nbsp;to&nbsp;dispaly<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Atoms-ismagnetic"><strong>ismagnetic</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;any&nbsp;ions&nbsp;have&nbsp;magnetic&nbsp;moments&nbsp;assigned</tt></dd></dl>

<dl><dt><a name="Atoms-mass_fraction"><strong>mass_fraction</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;mass&nbsp;fraction&nbsp;per&nbsp;element<br>
:return:&nbsp;float</tt></dd></dl>

<dl><dt><a name="Atoms-mxmymz"><strong>mxmymz</strong></a>(self)</dt><dd><tt>Returns&nbsp;a&nbsp;[nx3]&nbsp;array&nbsp;of&nbsp;magnetic&nbsp;vectors<br>
:return:&nbsp;np.array([nx3])</tt></dd></dl>

<dl><dt><a name="Atoms-remove_duplicates"><strong>remove_duplicates</strong></a>(self, min_distance=0.01, all_types=False)</dt><dd><tt>Remove&nbsp;atoms&nbsp;of&nbsp;the&nbsp;same&nbsp;type&nbsp;that&nbsp;are&nbsp;too&nbsp;close&nbsp;to&nbsp;each&nbsp;other<br>
:param&nbsp;min_distance:&nbsp;remove&nbsp;atoms&nbsp;within&nbsp;this&nbsp;distance,&nbsp;in&nbsp;fractional&nbsp;units<br>
:param&nbsp;all_types:&nbsp;if&nbsp;True,&nbsp;also&nbsp;remove&nbsp;atoms&nbsp;of&nbsp;different&nbsp;types<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Atoms-removeatom"><strong>removeatom</strong></a>(self, idx)</dt><dd><tt>Removes&nbsp;atom&nbsp;number&nbsp;idx&nbsp;from&nbsp;the&nbsp;list<br>
:param&nbsp;idx:&nbsp;int,&nbsp;atom&nbsp;index<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Atoms-total_moment"><strong>total_moment</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;total&nbsp;moment&nbsp;along&nbsp;a,&nbsp;b,&nbsp;c&nbsp;directions</tt></dd></dl>

<dl><dt><a name="Atoms-update_cif"><strong>update_cif</strong></a>(self, cifvals)</dt><dd><tt>Update&nbsp;cif&nbsp;dict&nbsp;with&nbsp;stored&nbsp;values<br>
:param&nbsp;cifvals:&nbsp;cif&nbsp;dict&nbsp;from&nbsp;readcif<br>
:return:&nbsp;cifvals</tt></dd></dl>

<dl><dt><a name="Atoms-uvw"><strong>uvw</strong></a>(self)</dt><dd><tt>Returns&nbsp;a&nbsp;[nx3]&nbsp;array&nbsp;of&nbsp;current&nbsp;positions<br>
:return:&nbsp;np.array([nx3])</tt></dd></dl>

<dl><dt><a name="Atoms-weight"><strong>weight</strong></a>(self)</dt><dd><tt>Calculate&nbsp;the&nbsp;molecular&nbsp;weight&nbsp;in&nbsp;g/mol&nbsp;of&nbsp;all&nbsp;the&nbsp;atoms<br>
:return:&nbsp;float</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Cell">class <strong>Cell</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Cell">Cell</a>(a=1.0,&nbsp;b=1.0,&nbsp;c=1.0,&nbsp;alpha=90.0,&nbsp;beta=90.0,&nbsp;gamma=90.0)<br>
&nbsp;<br>
Contains&nbsp;lattice&nbsp;parameters&nbsp;and&nbsp;unit&nbsp;cell<br>
Provides&nbsp;tools&nbsp;to&nbsp;convert&nbsp;between&nbsp;orthogonal&nbsp;and&nbsp;lattice&nbsp;bases&nbsp;in&nbsp;real&nbsp;and&nbsp;reciprocal&nbsp;space.<br>
&nbsp;<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;UC&nbsp;=&nbsp;<a href="#Cell">Cell</a>()&nbsp;#&nbsp;instantiate&nbsp;the&nbsp;<a href="#Cell">Cell</a>&nbsp;<a href="builtins.html#object">object</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;UC.<a href="#Cell-latt">latt</a>([2.85,2.85,10.8,90,90,120])&nbsp;#&nbsp;Define&nbsp;the&nbsp;lattice&nbsp;parameters&nbsp;from&nbsp;a&nbsp;list<br>
&nbsp;&nbsp;&nbsp;&nbsp;UC.<a href="#Cell-tth">tth</a>([0,0,12],energy_kev=8.0)&nbsp;#&nbsp;Calculate&nbsp;the&nbsp;two-theta&nbsp;of&nbsp;a&nbsp;reflection<br>
&nbsp;&nbsp;&nbsp;&nbsp;UC.<a href="#Cell-lp">lp</a>()&nbsp;#&nbsp;Returns&nbsp;the&nbsp;current&nbsp;lattice&nbsp;parameters<br>
&nbsp;&nbsp;&nbsp;&nbsp;UC.orientation&nbsp;#&nbsp;class&nbsp;to&nbsp;chanage&nbsp;cell&nbsp;orientation&nbsp;in&nbsp;space<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Cell-Bmatrix"><strong>Bmatrix</strong></a>(self)</dt><dd><tt>Calculate&nbsp;the&nbsp;Busing&nbsp;and&nbsp;Levy&nbsp;B&nbsp;matrix&nbsp;from&nbsp;a&nbsp;real&nbsp;space&nbsp;UV<br>
&nbsp;"choose&nbsp;the&nbsp;x-axis&nbsp;parallel&nbsp;to&nbsp;a*,&nbsp;the&nbsp;y-axis&nbsp;in&nbsp;the&nbsp;plane&nbsp;of&nbsp;a*&nbsp;and&nbsp;b*,&nbsp;and&nbsp;the&nbsp;z-axis&nbsp;perpendicular&nbsp;to<br>
&nbsp;that&nbsp;plane"<br>
&nbsp;W.&nbsp;R.&nbsp;Busing&nbsp;&amp;&nbsp;H.&nbsp;A.&nbsp;Levy,&nbsp;Acta&nbsp;&nbsp;Cryst.&nbsp;&nbsp;(1967).&nbsp;22,&nbsp;&nbsp;457</tt></dd></dl>

<dl><dt><a name="Cell-Qmag"><strong>Qmag</strong></a>(self, HKL)</dt><dd><tt>Returns&nbsp;the&nbsp;magnitude&nbsp;of&nbsp;wave-vector&nbsp;transfer&nbsp;of&nbsp;[h,k,l],&nbsp;in&nbsp;A-1<br>
:param&nbsp;HKL:&nbsp;list&nbsp;of&nbsp;hkl&nbsp;reflections<br>
:return:&nbsp;list&nbsp;of&nbsp;Q&nbsp;values</tt></dd></dl>

<dl><dt><a name="Cell-UV"><strong>UV</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;unit&nbsp;cell&nbsp;as&nbsp;a&nbsp;[3x3]&nbsp;array,&nbsp;[A,B,C]<br>
The&nbsp;vector&nbsp;A&nbsp;is&nbsp;directed&nbsp;along&nbsp;the&nbsp;x-axis</tt></dd></dl>

<dl><dt><a name="Cell-UVstar"><strong>UVstar</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;reciprocal&nbsp;unit&nbsp;cell&nbsp;as&nbsp;a&nbsp;[3x3]&nbsp;array,&nbsp;[A*,B*,C*]<br>
:return:&nbsp;[a*;b*;c*]</tt></dd></dl>

<dl><dt><a name="Cell-__init__"><strong>__init__</strong></a>(self, a=1.0, b=1.0, c=1.0, alpha=90.0, beta=90.0, gamma=90.0)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Cell-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Cell-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Cell-all_hkl"><strong>all_hkl</strong></a>(self, energy_kev=8.048, max_angle=180.0)</dt><dd><tt>Returns&nbsp;an&nbsp;array&nbsp;of&nbsp;all&nbsp;(h,k,l)&nbsp;reflections&nbsp;at&nbsp;this&nbsp;energy<br>
:param&nbsp;energy_kev:&nbsp;energy&nbsp;in&nbsp;keV<br>
:param&nbsp;max_angle:&nbsp;max&nbsp;two-theta&nbsp;angle<br>
:return:&nbsp;array&nbsp;hkl[:,3]</tt></dd></dl>

<dl><dt><a name="Cell-angle"><strong>angle</strong></a>(self, hkl1, hkl2)</dt><dd><tt>Return&nbsp;the&nbsp;angle&nbsp;between&nbsp;two&nbsp;reflections<br>
:param&nbsp;hkl1:&nbsp;[h,k,l]&nbsp;reflection&nbsp;1<br>
:param&nbsp;hkl2:&nbsp;[h,k,l]&nbsp;reflection&nbsp;2<br>
:return:&nbsp;angle&nbsp;in&nbsp;degrees</tt></dd></dl>

<dl><dt><a name="Cell-calculateQ"><strong>calculateQ</strong></a>(self, HKL)</dt><dd><tt>Convert&nbsp;coordinates&nbsp;[h,k,l],&nbsp;in&nbsp;the&nbsp;basis&nbsp;of&nbsp;the&nbsp;reciprocal&nbsp;lattice,&nbsp;to<br>
coordinates&nbsp;[x,y,z],&nbsp;in&nbsp;an&nbsp;orthogonal&nbsp;basis,&nbsp;in&nbsp;units&nbsp;of&nbsp;A-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q(x,y,z)&nbsp;=&nbsp;hA*&nbsp;+&nbsp;kB*&nbsp;+&nbsp;lC*<br>
&nbsp;<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;<a href="#Cell">Cell</a>.<a href="#Cell-calculateQ">calculateQ</a>([1,0,0])&nbsp;#&nbsp;for&nbsp;a&nbsp;hexagonal&nbsp;system,&nbsp;a&nbsp;=&nbsp;2.85<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;Q&nbsp;=&nbsp;array([[2.2046264,&nbsp;1.2728417,&nbsp;0.0000000]])</tt></dd></dl>

<dl><dt><a name="Cell-calculateR"><strong>calculateR</strong></a>(self, UVW)</dt><dd><tt>Convert&nbsp;coordinates&nbsp;[u,v,w],&nbsp;in&nbsp;the&nbsp;basis&nbsp;of&nbsp;the&nbsp;unit&nbsp;cell,&nbsp;to<br>
coordinates&nbsp;[x,y,z],&nbsp;in&nbsp;an&nbsp;orthogonal&nbsp;basis,&nbsp;in&nbsp;units&nbsp;of&nbsp;A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R(x,y,z)&nbsp;=&nbsp;uA&nbsp;+&nbsp;vB&nbsp;+&nbsp;wC<br>
&nbsp;<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;=&nbsp;<a href="#Cell">Cell</a>.<a href="#Cell-calculateR">calculateR</a>([0.1,0,0])&nbsp;#&nbsp;for&nbsp;a&nbsp;hexagonal&nbsp;system,&nbsp;a&nbsp;=&nbsp;2.85<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;R&nbsp;=&nbsp;array([[0.285,&nbsp;0,&nbsp;0]])</tt></dd></dl>

<dl><dt><a name="Cell-diff6circle"><strong>diff6circle</strong></a>(self, delta=0, gamma=0, energy_kev=None, wavelength=1.0)</dt><dd><tt>Calcualte&nbsp;wavevector&nbsp;in&nbsp;diffractometer&nbsp;axis&nbsp;using&nbsp;detector&nbsp;angles<br>
:param&nbsp;delta:&nbsp;float&nbsp;angle&nbsp;in&nbsp;degrees&nbsp;in&nbsp;vertical&nbsp;direction&nbsp;(about&nbsp;diff-z)<br>
:param&nbsp;gamma:&nbsp;float&nbsp;angle&nbsp;in&nbsp;degrees&nbsp;in&nbsp;horizontal&nbsp;direction&nbsp;(about&nbsp;diff-x)<br>
:param&nbsp;energy_kev:&nbsp;float&nbsp;energy&nbsp;in&nbsp;KeV<br>
:param&nbsp;wavelength:&nbsp;float&nbsp;wavelength&nbsp;in&nbsp;A<br>
:return:&nbsp;q[1*3],&nbsp;ki[1*3],&nbsp;kf[1*3]</tt></dd></dl>

<dl><dt><a name="Cell-diff6circle2hkl"><strong>diff6circle2hkl</strong></a>(self, phi=0, chi=0, eta=0, mu=0, delta=0, gamma=0, energy_kev=None, wavelength=1.0)</dt><dd><tt>Return&nbsp;[h,k,l]&nbsp;position&nbsp;of&nbsp;diffractometer&nbsp;axes&nbsp;at&nbsp;given&nbsp;energy<br>
:param&nbsp;phi:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;chi:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;eta:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;mu:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;delta:&nbsp;float&nbsp;detector&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;gamma:&nbsp;float&nbsp;detector&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;energy_kev:&nbsp;float&nbsp;energy&nbsp;in&nbsp;KeV<br>
:param&nbsp;wavelength:&nbsp;float&nbsp;wavelength&nbsp;in&nbsp;A<br>
:return:&nbsp;[h,k,l]</tt></dd></dl>

<dl><dt><a name="Cell-diff6circle_match"><strong>diff6circle_match</strong></a>(self, phi=0, chi=0, eta=0, mu=0, delta=0, gamma=0, energy_kev=None, wavelength=1.0, fwhm=0.5)</dt><dd><tt>Return&nbsp;the&nbsp;closest&nbsp;hkl&nbsp;and&nbsp;intensity&nbsp;factor<br>
:param&nbsp;phi:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;chi:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;eta:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;mu:&nbsp;float&nbsp;sample&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;delta:&nbsp;float&nbsp;detector&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;gamma:&nbsp;float&nbsp;detector&nbsp;angle&nbsp;in&nbsp;degrees<br>
:param&nbsp;energy_kev:&nbsp;float&nbsp;energy&nbsp;in&nbsp;KeV<br>
:param&nbsp;wavelength:&nbsp;float&nbsp;wavelength&nbsp;in&nbsp;A<br>
:param&nbsp;fwhm:&nbsp;float&nbsp;peak&nbsp;width&nbsp;in&nbsp;A-1<br>
:return:&nbsp;[h,k,l],&nbsp;If</tt></dd></dl>

<dl><dt><a name="Cell-dspace"><strong>dspace</strong></a>(self, hkl)</dt><dd><tt>Calculate&nbsp;the&nbsp;d-spacing&nbsp;in&nbsp;A<br>
:param&nbsp;hkl:&nbsp;array&nbsp;:&nbsp;list&nbsp;of&nbsp;reflections<br>
:return:&nbsp;d-spacing</tt></dd></dl>

<dl><dt><a name="Cell-find_close_reflections"><strong>find_close_reflections</strong></a>(self, hkl, energy_kev, max_twotheta=2, max_angle=10)</dt><dd><tt>Find&nbsp;reflections&nbsp;near&nbsp;to&nbsp;given&nbsp;HKL&nbsp;for&nbsp;a&nbsp;given&nbsp;two-theta&nbsp;or&nbsp;reflection&nbsp;angle<br>
:param&nbsp;hkl:&nbsp;[h,k,l]&nbsp;indices&nbsp;of&nbsp;reflection&nbsp;to&nbsp;start&nbsp;from<br>
:param&nbsp;energy_kev:&nbsp;energy&nbsp;in&nbsp;keV<br>
:param&nbsp;max_twotheta:&nbsp;matches&nbsp;reflections&nbsp;within&nbsp;two-theta&nbsp;of&nbsp;hkl<br>
:param&nbsp;max_angle:&nbsp;matches&nbsp;reflections&nbsp;within&nbsp;max_angle&nbsp;of&nbsp;hkl<br>
:return:&nbsp;list&nbsp;of&nbsp;matching&nbsp;[[h,k,l]]&nbsp;reflections</tt></dd></dl>

<dl><dt><a name="Cell-fromcif"><strong>fromcif</strong></a>(self, cifvals)</dt><dd><tt>Import&nbsp;lattice&nbsp;parameters&nbsp;from&nbsp;a&nbsp;cif&nbsp;dictionary<br>
Required&nbsp;CIF&nbsp;keys:<br>
&nbsp;&nbsp;&nbsp;&nbsp;_cell_length_a<br>
&nbsp;&nbsp;&nbsp;&nbsp;_cell_length_b<br>
&nbsp;&nbsp;&nbsp;&nbsp;_cell_length_c<br>
&nbsp;&nbsp;&nbsp;&nbsp;_cell_angle_alpha<br>
&nbsp;&nbsp;&nbsp;&nbsp;_cell_angle_beta<br>
&nbsp;&nbsp;&nbsp;&nbsp;_cell_angle_gamma<br>
:param&nbsp;cifvals:&nbsp;dict&nbsp;from&nbsp;readcif<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Cell-generate_lattice"><strong>generate_lattice</strong></a>(self, U, V, W)</dt><dd><tt>Returns&nbsp;the&nbsp;lattice&nbsp;parameters&nbsp;of&nbsp;a&nbsp;larger&nbsp;lattice</tt></dd></dl>

<dl><dt><a name="Cell-indexQ"><strong>indexQ</strong></a>(self, Q)</dt><dd><tt>Convert&nbsp;coordinates&nbsp;[x,y,z],&nbsp;in&nbsp;an&nbsp;orthogonal&nbsp;basis,&nbsp;to<br>
coordinates&nbsp;[h,k,l],&nbsp;in&nbsp;the&nbsp;basis&nbsp;of&nbsp;the&nbsp;reciprocal&nbsp;lattice<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H(h,k,l)&nbsp;=&nbsp;Q(x,y,z)&nbsp;/&nbsp;[A*,B*,C*]<br>
&nbsp;<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;HKL&nbsp;=&nbsp;<a href="#Cell-indexQ">indexQ</a>([2.2046264,&nbsp;1.2728417,&nbsp;0.0000000])&nbsp;#&nbsp;for&nbsp;a&nbsp;hexagonal&nbsp;system,&nbsp;a&nbsp;=&nbsp;2.85<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;HKL&nbsp;=&nbsp;[1,0,0]</tt></dd></dl>

<dl><dt><a name="Cell-indexR"><strong>indexR</strong></a>(self, R)</dt><dd><tt>Convert&nbsp;coordinates&nbsp;[x,y,z],&nbsp;in&nbsp;an&nbsp;orthogonal&nbsp;basis,&nbsp;to<br>
coordinates&nbsp;[u,v,w],&nbsp;in&nbsp;the&nbsp;basis&nbsp;of&nbsp;the&nbsp;unit&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U(u,v,w)&nbsp;=&nbsp;R(x,y,z)&nbsp;/&nbsp;[A,B,C]<br>
&nbsp;<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;UVW&nbsp;=&nbsp;<a href="#Cell-indexR">indexR</a>([0.285,&nbsp;0,&nbsp;0])&nbsp;#&nbsp;for&nbsp;a&nbsp;hexagonal&nbsp;system,&nbsp;a&nbsp;=&nbsp;2.85<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;UVW&nbsp;=&nbsp;[0.1,0,0]</tt></dd></dl>

<dl><dt><a name="Cell-info"><strong>info</strong></a>(self)</dt><dd><tt>&nbsp;Prints&nbsp;the&nbsp;lattice&nbsp;parameters&nbsp;and&nbsp;cell&nbsp;volume"<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Cell-labwavevector"><strong>labwavevector</strong></a>(self, hkl)</dt><dd><tt>Calculate&nbsp;the&nbsp;lab&nbsp;wavevector&nbsp;using&nbsp;the&nbsp;unit-vector,&nbsp;oritenation&nbsp;matrix&nbsp;and&nbsp;rotation&nbsp;matrix<br>
Returns&nbsp;vectors&nbsp;in&nbsp;the&nbsp;lab&nbsp;coordinate&nbsp;system,&nbsp;by&nbsp;default&nbsp;defined&nbsp;like&nbsp;Diamond&nbsp;Light&nbsp;Source:<br>
&nbsp;&nbsp;x-axis&nbsp;:&nbsp;away&nbsp;from&nbsp;synchrotron&nbsp;ring,&nbsp;towards&nbsp;wall<br>
&nbsp;&nbsp;y-axis&nbsp;:&nbsp;towards&nbsp;ceiling<br>
&nbsp;&nbsp;z-axis&nbsp;:&nbsp;along&nbsp;beam&nbsp;direction<br>
:param&nbsp;hkl:&nbsp;[3xn]&nbsp;array&nbsp;of&nbsp;(h,&nbsp;k,&nbsp;l)&nbsp;reciprocal&nbsp;lattice&nbsp;vectors<br>
:return:&nbsp;[3xn]&nbsp;array&nbsp;of&nbsp;Q&nbsp;vectors&nbsp;in&nbsp;the&nbsp;lab&nbsp;coordinate&nbsp;system</tt></dd></dl>

<dl><dt><a name="Cell-latt"><strong>latt</strong></a>(self, lattice_parameters=(), *args, **kwargs)</dt><dd><tt>Generate&nbsp;lattice&nbsp;parameters&nbsp;with&nbsp;list<br>
&nbsp;&nbsp;<a href="#Cell-latt">latt</a>(1)&nbsp;-&gt;&nbsp;a=b=c=1,alpha=beta=gamma=90<br>
&nbsp;&nbsp;<a href="#Cell-latt">latt</a>([1,2,3])&nbsp;-&gt;&nbsp;a=1,b=2,c=3,alpha=beta=gamma=90<br>
&nbsp;&nbsp;<a href="#Cell-latt">latt</a>([1,2,3,120])&nbsp;-&gt;&nbsp;a=1,b=2,c=3,alpha=beta=90,gamma=120<br>
&nbsp;&nbsp;<a href="#Cell-latt">latt</a>([1,2,3,10,20,30])&nbsp;-&gt;&nbsp;a=1,b=2,c=3,alpha=10,beta=20,gamma=30<br>
&nbsp;&nbsp;<a href="#Cell-latt">latt</a>(1,2,3,10,20,30)&nbsp;-&gt;&nbsp;a=1,b=2,c=3,alpha=10,beta=20,gamma=30<br>
&nbsp;&nbsp;<a href="#Cell-latt">latt</a>(a=1,b=2,c=3,alpha=10,beta=20,gamma=30])&nbsp;-&gt;&nbsp;a=1,b=2,c=3,alpha=10,beta=20,gamma=30</tt></dd></dl>

<dl><dt><a name="Cell-lp"><strong>lp</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;lattice&nbsp;parameters<br>
:return:&nbsp;a,b,c,alpha,beta,gamma</tt></dd></dl>

<dl><dt><a name="Cell-max_hkl"><strong>max_hkl</strong></a>(self, energy_kev=8.048, max_angle=180.0)</dt><dd><tt>Returns&nbsp;the&nbsp;maximum&nbsp;index&nbsp;of&nbsp;h,&nbsp;k&nbsp;and&nbsp;l&nbsp;for&nbsp;a&nbsp;given&nbsp;energy<br>
:param&nbsp;energy_kev:&nbsp;energy&nbsp;in&nbsp;keV<br>
:param&nbsp;max_angle:&nbsp;maximum&nbsp;two-theta&nbsp;at&nbsp;this&nbsp;energy<br>
:return:&nbsp;maxh,&nbsp;maxk,&nbsp;maxl</tt></dd></dl>

<dl><dt><a name="Cell-moment"><strong>moment</strong></a>(self, mxmymz)</dt><dd><tt>Calcualte&nbsp;moment&nbsp;from&nbsp;value&nbsp;stored&nbsp;in&nbsp;cif</tt></dd></dl>

<dl><dt><a name="Cell-powder_average"><strong>powder_average</strong></a>(self, hkl)</dt><dd><tt>Returns&nbsp;the&nbsp;powder&nbsp;average&nbsp;correction&nbsp;for&nbsp;the&nbsp;given&nbsp;hkl<br>
:param&nbsp;hkl:&nbsp;array&nbsp;:&nbsp;list&nbsp;of&nbsp;reflections<br>
:return:&nbsp;correction</tt></dd></dl>

<dl><dt><a name="Cell-reciprocal_space_plane"><strong>reciprocal_space_plane</strong></a>(self, x_axis=[1, 0, 0], y_axis=[0, 1, 0], centre=[0, 0, 0], q_max=4.0, cut_width=0.05)</dt><dd><tt>Returns&nbsp;positions&nbsp;within&nbsp;a&nbsp;reciprocal&nbsp;space&nbsp;plane<br>
&nbsp;&nbsp;x_axis&nbsp;=&nbsp;direction&nbsp;along&nbsp;x,&nbsp;in&nbsp;units&nbsp;of&nbsp;the&nbsp;reciprocal&nbsp;lattice&nbsp;(hkl)<br>
&nbsp;&nbsp;y_axis&nbsp;=&nbsp;direction&nbsp;along&nbsp;y,&nbsp;in&nbsp;units&nbsp;of&nbsp;the&nbsp;reciprocal&nbsp;lattice&nbsp;(hkl)<br>
&nbsp;&nbsp;centre&nbsp;=&nbsp;centre&nbsp;of&nbsp;the&nbsp;plot,&nbsp;in&nbsp;units&nbsp;of&nbsp;the&nbsp;reciprocal&nbsp;lattice&nbsp;(hkl)<br>
&nbsp;&nbsp;q_max&nbsp;=&nbsp;maximum&nbsp;distance&nbsp;to&nbsp;plot&nbsp;to&nbsp;-&nbsp;in&nbsp;A-1<br>
&nbsp;<br>
Returns:&nbsp;X,Y,HKL<br>
&nbsp;&nbsp;Qx&nbsp;=&nbsp;[nx1]&nbsp;array&nbsp;of&nbsp;x&nbsp;positions&nbsp;for&nbsp;each&nbsp;HKL&nbsp;in&nbsp;the&nbsp;plane<br>
&nbsp;&nbsp;Qy&nbsp;=&nbsp;[nx1]&nbsp;array&nbsp;of&nbsp;y&nbsp;positions&nbsp;for&nbsp;each&nbsp;HKL&nbsp;in&nbsp;the&nbsp;plane<br>
&nbsp;&nbsp;HKL=&nbsp;[nx1]&nbsp;array&nbsp;of&nbsp;each&nbsp;HKL&nbsp;in&nbsp;the&nbsp;plane</tt></dd></dl>

<dl><dt><a name="Cell-reflection_hkl"><strong>reflection_hkl</strong></a>(self, energy_kev=8.048, max_angle=180.0, specular=(0, 0, 1), theta_offset=0, min_theta=0, max_theta=180.0)</dt><dd><tt>Returns&nbsp;an&nbsp;array&nbsp;of&nbsp;all&nbsp;(h,k,l)&nbsp;reflections&nbsp;in&nbsp;reflection&nbsp;geometry<br>
:param&nbsp;energy_kev:&nbsp;energy&nbsp;in&nbsp;keV<br>
:param&nbsp;max_angle:&nbsp;max&nbsp;two-theta&nbsp;angle<br>
:param&nbsp;specular:&nbsp;(h,k,l)&nbsp;of&nbsp;direction&nbsp;normal&nbsp;to&nbsp;surface&nbsp;and&nbsp;the&nbsp;incident&nbsp;beam<br>
:param&nbsp;theta_offset:&nbsp;float&nbsp;:&nbsp;angle&nbsp;(deg)&nbsp;of&nbsp;surface&nbsp;relative&nbsp;to&nbsp;specular&nbsp;normal<br>
:param&nbsp;min_theta:&nbsp;float&nbsp;:&nbsp;cut&nbsp;hkl&nbsp;reflections&nbsp;with&nbsp;reflection-theta&nbsp;lower&nbsp;than&nbsp;min_theta<br>
:param&nbsp;max_theta:&nbsp;flaot&nbsp;:&nbsp;cut&nbsp;hkl&nbsp;reflections&nbsp;with&nbsp;reflection-theta&nbsp;greater&nbsp;than&nbsp;max_theta<br>
:return:&nbsp;array&nbsp;of&nbsp;hkl</tt></dd></dl>

<dl><dt><a name="Cell-sort_hkl"><strong>sort_hkl</strong></a>(self, hkl, ascend=True)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;(h,k,l)&nbsp;sorted&nbsp;by&nbsp;two-theta<br>
:param&nbsp;hkl:&nbsp;array&nbsp;:&nbsp;list&nbsp;of&nbsp;[h,k,l]&nbsp;values<br>
:param&nbsp;ascend:&nbsp;True*/False&nbsp;:&nbsp;if&nbsp;False,&nbsp;lowest&nbsp;two-theta<br>
:return:&nbsp;HKL[sorted,:]</tt></dd></dl>

<dl><dt><a name="Cell-theta_reflection"><strong>theta_reflection</strong></a>(self, HKL, energy_kev=8.048, specular=[0, 0, 1], theta_offset=0)</dt><dd><tt>Calculate&nbsp;the&nbsp;sample&nbsp;angle&nbsp;for&nbsp;diffraction&nbsp;in&nbsp;reflection&nbsp;geometry&nbsp;given&nbsp;a&nbsp;particular&nbsp;specular&nbsp;direction</tt></dd></dl>

<dl><dt><a name="Cell-theta_transmission"><strong>theta_transmission</strong></a>(self, HKL, energy_kev=8.048, parallel=[0, 0, 1], theta_offset=0)</dt><dd><tt>Calculate&nbsp;the&nbsp;sample&nbsp;angle&nbsp;for&nbsp;diffraction&nbsp;in&nbsp;transmission&nbsp;geometry&nbsp;given<br>
a&nbsp;particular&nbsp;direction&nbsp;parallel&nbsp;to&nbsp;the&nbsp;beam</tt></dd></dl>

<dl><dt><a name="Cell-transmission_hkl"><strong>transmission_hkl</strong></a>(self, energy_kev=8.048, max_angle=180.0, parallel=(0, 0, 1), theta_offset=0, min_theta=0, max_theta=180.0)</dt><dd><tt>Returns&nbsp;an&nbsp;array&nbsp;of&nbsp;all&nbsp;(h,k,l)&nbsp;reflections&nbsp;in&nbsp;reflection&nbsp;geometry<br>
:param&nbsp;energy_kev:&nbsp;energy&nbsp;in&nbsp;keV<br>
:param&nbsp;max_angle:&nbsp;max&nbsp;two-theta&nbsp;angle<br>
:param&nbsp;parallel:&nbsp;(h,k,l)&nbsp;of&nbsp;direction&nbsp;normal&nbsp;to&nbsp;surface,&nbsp;parallel&nbsp;to&nbsp;the&nbsp;incident&nbsp;beam<br>
:param&nbsp;theta_offset:&nbsp;float&nbsp;:&nbsp;angle&nbsp;(deg)&nbsp;of&nbsp;surface&nbsp;relative&nbsp;to&nbsp;specular&nbsp;normal<br>
:param&nbsp;min_theta:&nbsp;float&nbsp;:&nbsp;cut&nbsp;hkl&nbsp;reflections&nbsp;with&nbsp;reflection-theta&nbsp;lower&nbsp;than&nbsp;min_theta<br>
:param&nbsp;max_theta:&nbsp;flaot&nbsp;:&nbsp;cut&nbsp;hkl&nbsp;reflections&nbsp;with&nbsp;reflection-theta&nbsp;greater&nbsp;than&nbsp;max_theta<br>
:return:&nbsp;array&nbsp;of&nbsp;hkl</tt></dd></dl>

<dl><dt><a name="Cell-tth"><strong>tth</strong></a>(self, HKL, energy_kev=8.048)</dt><dd><tt>Returns&nbsp;the&nbsp;two-theta&nbsp;angle,&nbsp;in&nbsp;deg,&nbsp;of&nbsp;[h,k,l]&nbsp;at&nbsp;specified&nbsp;energy&nbsp;in&nbsp;keV<br>
:param&nbsp;HKL:&nbsp;list&nbsp;of&nbsp;hkl&nbsp;reflections<br>
:param&nbsp;energy_kev:&nbsp;energy&nbsp;in&nbsp;keV<br>
:return:&nbsp;two-theta&nbsp;angles</tt></dd></dl>

<dl><dt><a name="Cell-ubmatrix"><strong>ubmatrix</strong></a>(self)</dt><dd><tt>Return&nbsp;UB&nbsp;matrix&nbsp;from&nbsp;Busing&nbsp;&amp;&nbsp;Levy&nbsp;in&nbsp;the&nbsp;diffractometer&nbsp;frame</tt></dd></dl>

<dl><dt><a name="Cell-update_cif"><strong>update_cif</strong></a>(self, cifvals)</dt><dd><tt>Update&nbsp;cif&nbsp;dict&nbsp;with&nbsp;current&nbsp;values<br>
:param&nbsp;cifvals:&nbsp;dict&nbsp;from&nbsp;readcif<br>
:return:&nbsp;cifvals</tt></dd></dl>

<dl><dt><a name="Cell-volume"><strong>volume</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;volume&nbsp;of&nbsp;the&nbsp;unit&nbsp;cell,&nbsp;in&nbsp;A^3<br>
:return:&nbsp;volume</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Crystal">class <strong>Crystal</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Crystal-name">Crystal</a>(filename=None)<br>
&nbsp;<br>
Reads&nbsp;the&nbsp;structure&nbsp;information&nbsp;from&nbsp;a&nbsp;cif&nbsp;file&nbsp;and&nbsp;generates&nbsp;the&nbsp;full&nbsp;structure.<br>
Allows&nbsp;the&nbsp;adjustment&nbsp;of&nbsp;the&nbsp;structure&nbsp;through&nbsp;the&nbsp;lattice&nbsp;parameters,&nbsp;symmetry&nbsp;<br>
or&nbsp;atomic&nbsp;displacement.<br>
Can&nbsp;calculate&nbsp;reflection&nbsp;intensities&nbsp;and&nbsp;two-theta&nbsp;values.<br>
&nbsp;<br>
E.G.<br>
&nbsp;&nbsp;xtl&nbsp;=&nbsp;<a href="#Crystal-name">Crystal</a>('Diamond.cif')<br>
&nbsp;&nbsp;xtl.<a href="#Cell">Cell</a>.lp()&nbsp;&gt;&gt;&nbsp;give&nbsp;the&nbsp;lattice&nbsp;parameters<br>
&nbsp;&nbsp;xtl.<a href="#Atoms">Atoms</a>.uvw()&nbsp;&gt;&gt;&nbsp;give&nbsp;the&nbsp;symmetric&nbsp;atomic&nbsp;positions<br>
&nbsp;&nbsp;xtl.<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;&gt;&gt;&nbsp;give&nbsp;symmetry&nbsp;operations<br>
&nbsp;&nbsp;xtl.Structure.uvw()&nbsp;&gt;&gt;&nbsp;give&nbsp;the&nbsp;full,&nbsp;unsymmetrised&nbsp;structure<br>
&nbsp;&nbsp;xtl.Scatter.hkl([1,0,0],8.00)&nbsp;&gt;&gt;&nbsp;prints&nbsp;the&nbsp;intensity&nbsp;and&nbsp;two-theta&nbsp;of&nbsp;this&nbsp;reflection&nbsp;at&nbsp;this&nbsp;energy<br>
&nbsp;&nbsp;xtl.Scatter.print_all_reflections(8.00)&nbsp;&gt;&gt;&nbsp;print&nbsp;all&nbsp;allowed&nbsp;reflections,&nbsp;with&nbsp;intensities,&nbsp;at&nbsp;this&nbsp;energy<br>
&nbsp;&nbsp;xtl.<a href="#Crystal-write_cif">write_cif</a>('Diamond2.cif')&nbsp;&gt;&gt;&nbsp;write&nbsp;updated&nbsp;structure&nbsp;to&nbsp;file<br>
&nbsp;<br>
To&nbsp;create&nbsp;your&nbsp;own&nbsp;crystal&nbsp;(BCC&nbsp;example):<br>
&nbsp;&nbsp;xtl&nbsp;=&nbsp;<a href="#Crystal-name">Crystal</a>()<br>
&nbsp;&nbsp;xtl.new_latt([2.866])<br>
&nbsp;&nbsp;xtl.<a href="#Crystal-new_atoms">new_atoms</a>(u=[0,0.5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v=[0,0.5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w=[0,0.5],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type=['Fe','Fe'])<br>
&nbsp;&nbsp;xtl.hkl([[1,0,0],[1,1,0],[1,1,1],[2,0,0]])<br>
&nbsp;<br>
Also,&nbsp;see:<br>
&nbsp;&nbsp;&nbsp;&nbsp;help(xtl.<a href="#Cell">Cell</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;help(xtl.<a href="#Atoms">Atoms</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;help(xtl.<a href="#Symmetry">Symmetry</a>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;help(xtl.Scatter)<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Crystal-__add__"><strong>__add__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Crystal-__init__"><strong>__init__</strong></a>(self, filename=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Crystal-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Crystal-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Crystal-add_parent"><strong>add_parent</strong></a>(self, parent, P)</dt><dd><tt>Add&nbsp;parent&nbsp;structure,&nbsp;returning&nbsp;<a href="#Crystal">Crystal</a>&nbsp;as&nbsp;superstructure<br>
&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;=&nbsp;<a href="#Crystal-name">Crystal</a>(cif_parent)<br>
&nbsp;&nbsp;&nbsp;&nbsp;xtl&nbsp;=&nbsp;<a href="#Crystal-name">Crystal</a>(cif_superstructure)<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;xtl.<a href="#Crystal-add_parent">add_parent</a>(parent,&nbsp;[[1,1,0],[0,2,0],[0,0,1]])</tt></dd></dl>

<dl><dt><a name="Crystal-generate_lattice"><strong>generate_lattice</strong></a>(self, U=1, V=1, W=0)</dt><dd><tt>Generate&nbsp;a&nbsp;repeated&nbsp;lattice&nbsp;of&nbsp;the&nbsp;crystal&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;latt&nbsp;=&nbsp;xtl.<a href="#Crystal-generate_lattice">generate_lattice</a>(2,0,0)<br>
:param&nbsp;U:&nbsp;Repeat&nbsp;of&nbsp;the&nbsp;cell&nbsp;along&nbsp;the&nbsp;a&nbsp;axis<br>
:param&nbsp;V:&nbsp;Repeat&nbsp;of&nbsp;the&nbsp;cell&nbsp;along&nbsp;the&nbsp;b&nbsp;axis<br>
:param&nbsp;W:&nbsp;Repeat&nbsp;of&nbsp;the&nbsp;cell&nbsp;along&nbsp;the&nbsp;c&nbsp;axis<br>
:return:&nbsp;<a href="#Crystal">Crystal</a>&nbsp;<a href="builtins.html#object">object</a></tt></dd></dl>

<dl><dt><a name="Crystal-generate_structure"><strong>generate_structure</strong></a>(self)</dt><dd><tt>Combines&nbsp;the&nbsp;atomic&nbsp;positions&nbsp;with&nbsp;symmetry&nbsp;operations,&nbsp;returning&nbsp;the&nbsp;full&nbsp;structure&nbsp;as&nbsp;an&nbsp;<a href="#Atoms">Atoms</a>&nbsp;class<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Crystal-generate_superstructure"><strong>generate_superstructure</strong></a>(self, P)</dt><dd><tt>Generate&nbsp;a&nbsp;superstructure&nbsp;of&nbsp;the&nbsp;current&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;a'&nbsp;=&nbsp;n1a&nbsp;+&nbsp;n2b&nbsp;+&nbsp;n3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;b'&nbsp;=&nbsp;m1a&nbsp;+&nbsp;m2b&nbsp;+&nbsp;m3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;c'&nbsp;=&nbsp;o1a&nbsp;+&nbsp;o2b&nbsp;+&nbsp;o3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;[a',b',c']&nbsp;=&nbsp;P[a,b,c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;[[n1,n2,n3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[m1,m2,m3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[o1,o2,o3]]<br>
Returns&nbsp;a&nbsp;superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;xtl.generate_superstructrue([[2,0,0],[0,2,0],[0,0,1]])<br>
&nbsp;<br>
<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;classes&nbsp;have&nbsp;additional&nbsp;attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.P&nbsp;=&nbsp;P&nbsp;as&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.Parent&nbsp;=&nbsp;the&nbsp;parent&nbsp;<a href="#Crystal">Crystal</a>&nbsp;Class<br>
&nbsp;<br>
Use&nbsp;&gt;&gt;hasattr(su,'Parent')&nbsp;to&nbsp;check&nbsp;if&nbsp;the&nbsp;current&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;a<br>
superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class</tt></dd></dl>

<dl><dt><a name="Crystal-info"><strong>info</strong></a>(self)</dt><dd><tt>Returns&nbsp;information&nbsp;about&nbsp;the&nbsp;crystal&nbsp;structure<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Crystal-invert_structure"><strong>invert_structure</strong></a>(self)</dt><dd><tt>Convert&nbsp;handedness&nbsp;of&nbsp;structure,&nbsp;transform&nbsp;from&nbsp;left-handed&nbsp;to&nbsp;right&nbsp;handed,&nbsp;or&nbsp;visa-versa<br>
Equivlent&nbsp;to&nbsp;xtl.<a href="#Crystal-transform">transform</a>([[-1,0,0],&nbsp;[0,-1,0],&nbsp;[0,0,-1]])<br>
:return:&nbsp;<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class</tt></dd></dl>

<dl><dt><a name="Crystal-new_atoms"><strong>new_atoms</strong></a>(self, u=[0], v=[0], w=[0], type=None, label=None, occupancy=None, uiso=None, mxmymz=None)</dt><dd><tt>Replace&nbsp;current&nbsp;atomic&nbsp;positions&nbsp;with&nbsp;new&nbsp;ones&nbsp;and&nbsp;regenerate&nbsp;structure<br>
:param&nbsp;u:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;positions&nbsp;u<br>
:param&nbsp;v:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;positions&nbsp;v<br>
:param&nbsp;w:&nbsp;&nbsp;array&nbsp;:&nbsp;atomic&nbsp;positions&nbsp;w<br>
:param&nbsp;type:&nbsp;&nbsp;array&nbsp;:&nbsp;atomic&nbsp;types<br>
:param&nbsp;label:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;labels<br>
:param&nbsp;occupancy:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;occupation<br>
:param&nbsp;uiso:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;isotropic&nbsp;thermal&nbsp;parameters<br>
:param&nbsp;mxmymz:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;magnetic&nbsp;vectors&nbsp;[mu,mv,mw]<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Crystal-new_cell"><strong>new_cell</strong></a>(self, lattice_parameters=(), *args, **kwargs)</dt><dd><tt>Replace&nbsp;the&nbsp;lattice&nbsp;parameters<br>
:param&nbsp;lattice_parameters:&nbsp;[a,b,c,alpha,beta,gamma]<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Crystal-start_gui"><strong>start_gui</strong></a>(self)</dt><dd><tt>Start&nbsp;<a href="#Crystal">Crystal</a>&nbsp;GUI<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Crystal-transform"><strong>transform</strong></a>(self, P)</dt><dd><tt>Transform&nbsp;the&nbsp;current&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;a'&nbsp;=&nbsp;n1a&nbsp;+&nbsp;n2b&nbsp;+&nbsp;n3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;b'&nbsp;=&nbsp;m1a&nbsp;+&nbsp;m2b&nbsp;+&nbsp;m3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;c'&nbsp;=&nbsp;o1a&nbsp;+&nbsp;o2b&nbsp;+&nbsp;o3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;[a',b',c']&nbsp;=&nbsp;P[a,b,c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;[[n1,n2,n3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[m1,m2,m3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[o1,o2,o3]]<br>
Returns&nbsp;a&nbsp;superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;xtl.<a href="#Crystal-transform">transform</a>([[0,1,0],[1,0,0],[0,0,1]])<br>
&nbsp;<br>
<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;classes&nbsp;have&nbsp;additional&nbsp;attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.P&nbsp;=&nbsp;P&nbsp;as&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.Parent&nbsp;=&nbsp;the&nbsp;parent&nbsp;<a href="#Crystal">Crystal</a>&nbsp;Class<br>
&nbsp;<br>
Use&nbsp;&gt;&gt;hasattr(su,'Parent')&nbsp;to&nbsp;check&nbsp;if&nbsp;the&nbsp;current&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;a<br>
superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class</tt></dd></dl>

<dl><dt><a name="Crystal-update_cif"><strong>update_cif</strong></a>(self, cifvals=None)</dt><dd><tt>Update&nbsp;self.<strong>cif</strong>&nbsp;dict&nbsp;with&nbsp;current&nbsp;values<br>
:param&nbsp;cifvals:&nbsp;cif&nbsp;dict&nbsp;from&nbsp;readcif&nbsp;(None&nbsp;to&nbsp;use&nbsp;self.<strong>cif</strong>)<br>
:return:&nbsp;cifvals</tt></dd></dl>

<dl><dt><a name="Crystal-write_cif"><strong>write_cif</strong></a>(self, filename=None, comments=None)</dt><dd><tt>Write&nbsp;crystal&nbsp;structure&nbsp;to&nbsp;CIF&nbsp;(Crystallographic&nbsp;Information&nbsp;File)<br>
&nbsp;Only&nbsp;basic&nbsp;information&nbsp;is&nbsp;saved&nbsp;to&nbsp;the&nbsp;file,&nbsp;but&nbsp;enough&nbsp;to&nbsp;open&nbsp;in&nbsp;VESTA&nbsp;etc.<br>
&nbsp;If&nbsp;magnetic&nbsp;ions&nbsp;are&nbsp;defined,&nbsp;a&nbsp;magnetic&nbsp;cif&nbsp;(*.mcif)&nbsp;will&nbsp;be&nbsp;produce<br>
:param&nbsp;filename:&nbsp;name&nbsp;to&nbsp;write&nbsp;too,&nbsp;if&nbsp;None,&nbsp;use&nbsp;writes&nbsp;to&nbsp;self.<strong>name</strong>&nbsp;(.cif/.mcif)<br>
:param&nbsp;comments:&nbsp;str&nbsp;comments&nbsp;to&nbsp;add&nbsp;to&nbsp;file&nbsp;header<br>
:return:&nbsp;None</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>cif</strong> = {}</dl>

<dl><dt><strong>filename</strong> = ''</dl>

<dl><dt><strong>name</strong> = 'Crystal'</dl>

<dl><dt><strong>scale</strong> = 1.0</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Superstructure">class <strong>Superstructure</strong></a>(<a href="Dans_Diffraction.classes_crystal.html#Crystal">Crystal</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Superstructure">Superstructure</a>(Parent,&nbsp;P)<br>
&nbsp;<br>
Generate&nbsp;a&nbsp;superstructure&nbsp;of&nbsp;the&nbsp;current&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;a'&nbsp;=&nbsp;n1a&nbsp;+&nbsp;n2b&nbsp;+&nbsp;n3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;b'&nbsp;=&nbsp;m1a&nbsp;+&nbsp;m2b&nbsp;+&nbsp;m3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;c'&nbsp;=&nbsp;o1a&nbsp;+&nbsp;o2b&nbsp;+&nbsp;o3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;[a',b',c']&nbsp;=&nbsp;P[a,b,c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;[[n1,n2,n3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[m1,m2,m3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[o1,o2,o3]]<br>
Returns&nbsp;a&nbsp;superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class:<br>
&nbsp;&nbsp;&nbsp;&nbsp;xtl&nbsp;=&nbsp;<a href="#Superstructure-name">Crystal</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;<a href="#Superstructure">Superstructure</a>(xtl,[[2,0,0],[0,2,0],[0,0,1]])<br>
&nbsp;<br>
<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;classes&nbsp;have&nbsp;additional&nbsp;attributes&nbsp;compared&nbsp;with&nbsp;<a href="#Crystal">Crystal</a>&nbsp;classes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.P&nbsp;=&nbsp;P&nbsp;as&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.Parent&nbsp;=&nbsp;the&nbsp;parent&nbsp;<a href="#Crystal">Crystal</a>&nbsp;Class<br>
And&nbsp;additional&nbsp;functions:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.calculateQ_parent&nbsp;&gt;&gt;&nbsp;indexes&nbsp;(h,k,l)&nbsp;coordinates&nbsp;in&nbsp;the&nbsp;frame&nbsp;same&nbsp;cartesian&nbsp;frame&nbsp;as&nbsp;the&nbsp;Parent&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.superhkl2parent&nbsp;&gt;&gt;&nbsp;indexes&nbsp;(h,k,l)&nbsp;coordinates&nbsp;in&nbsp;the&nbsp;frame&nbsp;of&nbsp;the&nbsp;Parent&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.parenthkl2super&nbsp;&gt;&gt;&nbsp;indexes&nbsp;parent&nbsp;(h,k,l)&nbsp;coordinates&nbsp;in&nbsp;the&nbsp;frame&nbsp;of&nbsp;superstructure<br>
&nbsp;<br>
Use&nbsp;&gt;&gt;hasattr(su,'Parent')&nbsp;to&nbsp;check&nbsp;is&nbsp;the&nbsp;current&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;a<br>
superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="Dans_Diffraction.classes_crystal.html#Superstructure">Superstructure</a></dd>
<dd><a href="Dans_Diffraction.classes_crystal.html#Crystal">Crystal</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Superstructure-__init__"><strong>__init__</strong></a>(self, Parent, P)</dt><dd><tt>Initialise</tt></dd></dl>

<dl><dt><a name="Superstructure-calculateQ_parent"><strong>calculateQ_parent</strong></a>(self, super_hkl)</dt><dd><tt>Indexes&nbsp;(h,k,l)&nbsp;coordinates&nbsp;in&nbsp;the&nbsp;frame&nbsp;same&nbsp;cartesian&nbsp;frame&nbsp;as&nbsp;the&nbsp;Parent&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;h'*a'*&nbsp;+&nbsp;k'*b'*&nbsp;+&nbsp;l'*c'*<br>
Where&nbsp;a'*,&nbsp;b'*,&nbsp;c'*&nbsp;are&nbsp;defined&nbsp;relative&nbsp;to&nbsp;the&nbsp;parent&nbsp;lattice,&nbsp;a*,b*,c*<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[qx,qy,qz]&nbsp;=&nbsp;<a href="#Superstructure-calculateQ_parent">calculateQ_parent</a>([h',k',l'])</tt></dd></dl>

<dl><dt><a name="Superstructure-generate_super_positions"><strong>generate_super_positions</strong></a>(self)</dt><dd><tt>Generate&nbsp;the&nbsp;supercell&nbsp;and&nbsp;superstructure&nbsp;based&nbsp;on&nbsp;P&nbsp;and&nbsp;parent&nbsp;structure<br>
:return:&nbsp;None,&nbsp;set&nbsp;new&nbsp;atom&nbsp;positions</tt></dd></dl>

<dl><dt><a name="Superstructure-parentUV"><strong>parentUV</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;parent&nbsp;unit&nbsp;vectors&nbsp;defined&nbsp;relative&nbsp;to&nbsp;the&nbsp;supercell</tt></dd></dl>

<dl><dt><a name="Superstructure-parentUVstar"><strong>parentUVstar</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;parent&nbsp;reciprocal&nbsp;cell&nbsp;unit&nbsp;vectors&nbsp;defined&nbsp;relative&nbsp;to&nbsp;the&nbsp;supercell</tt></dd></dl>

<dl><dt><a name="Superstructure-parenthkl2super"><strong>parenthkl2super</strong></a>(self, parent_HKL)</dt><dd><tt>Indexes&nbsp;(h,k,l)&nbsp;coordinates&nbsp;in&nbsp;the&nbsp;frame&nbsp;of&nbsp;the&nbsp;Parent&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;h*a*&nbsp;+&nbsp;k*b*&nbsp;+&nbsp;l*c*&nbsp;=&nbsp;h'*a'*&nbsp;+&nbsp;k'*b'*&nbsp;+&nbsp;l'*c'*<br>
&nbsp;&nbsp;&nbsp;&nbsp;[h',k',l']&nbsp;=&nbsp;Q/[a'*,b'*,c'*]<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[h',k',l']&nbsp;=&nbsp;<a href="#Superstructure-parenthkl2super">parenthkl2super</a>([h,k,l])</tt></dd></dl>

<dl><dt><a name="Superstructure-set_scale"><strong>set_scale</strong></a>(self)</dt><dd><tt>Set&nbsp;scale&nbsp;parameter&nbsp;automatically<br>
Based&nbsp;on&nbsp;ratio&nbsp;of&nbsp;parent&nbsp;-&nbsp;to&nbsp;superstructure&nbsp;volume</tt></dd></dl>

<dl><dt><a name="Superstructure-superUV"><strong>superUV</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;supercell&nbsp;unit&nbsp;vectors&nbsp;defined&nbsp;relative&nbsp;to&nbsp;the&nbsp;Parent&nbsp;cell</tt></dd></dl>

<dl><dt><a name="Superstructure-superUVstar"><strong>superUVstar</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;reciprocal&nbsp;supercell&nbsp;unit&nbsp;vectors&nbsp;defined&nbsp;relative&nbsp;to&nbsp;the&nbsp;Parent&nbsp;cell</tt></dd></dl>

<dl><dt><a name="Superstructure-superhkl2parent"><strong>superhkl2parent</strong></a>(self, super_HKL)</dt><dd><tt>Indexes&nbsp;(h,k,l)&nbsp;coordinates&nbsp;in&nbsp;the&nbsp;frame&nbsp;of&nbsp;the&nbsp;Parent&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;h*a*&nbsp;+&nbsp;k*b*&nbsp;+&nbsp;l*c*&nbsp;=&nbsp;h'*a'*&nbsp;+&nbsp;k'*b'*&nbsp;+&nbsp;l'*c'*<br>
&nbsp;&nbsp;&nbsp;&nbsp;[h',k',l']&nbsp;=&nbsp;Q/[a'*,b'*,c'*]<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;[h,k,l]&nbsp;=&nbsp;<a href="#Superstructure-superhkl2parent">superhkl2parent</a>([h',k',l'])</tt></dd></dl>

<hr>
Methods inherited from <a href="Dans_Diffraction.classes_crystal.html#Crystal">Crystal</a>:<br>
<dl><dt><a name="Superstructure-__add__"><strong>__add__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Superstructure-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Superstructure-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Superstructure-add_parent"><strong>add_parent</strong></a>(self, parent, P)</dt><dd><tt>Add&nbsp;parent&nbsp;structure,&nbsp;returning&nbsp;<a href="#Crystal">Crystal</a>&nbsp;as&nbsp;superstructure<br>
&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;=&nbsp;<a href="#Superstructure-name">Crystal</a>(cif_parent)<br>
&nbsp;&nbsp;&nbsp;&nbsp;xtl&nbsp;=&nbsp;<a href="#Superstructure-name">Crystal</a>(cif_superstructure)<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;xtl.<a href="#Superstructure-add_parent">add_parent</a>(parent,&nbsp;[[1,1,0],[0,2,0],[0,0,1]])</tt></dd></dl>

<dl><dt><a name="Superstructure-generate_lattice"><strong>generate_lattice</strong></a>(self, U=1, V=1, W=0)</dt><dd><tt>Generate&nbsp;a&nbsp;repeated&nbsp;lattice&nbsp;of&nbsp;the&nbsp;crystal&nbsp;structure<br>
&nbsp;&nbsp;&nbsp;&nbsp;latt&nbsp;=&nbsp;xtl.<a href="#Superstructure-generate_lattice">generate_lattice</a>(2,0,0)<br>
:param&nbsp;U:&nbsp;Repeat&nbsp;of&nbsp;the&nbsp;cell&nbsp;along&nbsp;the&nbsp;a&nbsp;axis<br>
:param&nbsp;V:&nbsp;Repeat&nbsp;of&nbsp;the&nbsp;cell&nbsp;along&nbsp;the&nbsp;b&nbsp;axis<br>
:param&nbsp;W:&nbsp;Repeat&nbsp;of&nbsp;the&nbsp;cell&nbsp;along&nbsp;the&nbsp;c&nbsp;axis<br>
:return:&nbsp;<a href="#Crystal">Crystal</a>&nbsp;<a href="builtins.html#object">object</a></tt></dd></dl>

<dl><dt><a name="Superstructure-generate_structure"><strong>generate_structure</strong></a>(self)</dt><dd><tt>Combines&nbsp;the&nbsp;atomic&nbsp;positions&nbsp;with&nbsp;symmetry&nbsp;operations,&nbsp;returning&nbsp;the&nbsp;full&nbsp;structure&nbsp;as&nbsp;an&nbsp;<a href="#Atoms">Atoms</a>&nbsp;class<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Superstructure-generate_superstructure"><strong>generate_superstructure</strong></a>(self, P)</dt><dd><tt>Generate&nbsp;a&nbsp;superstructure&nbsp;of&nbsp;the&nbsp;current&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;a'&nbsp;=&nbsp;n1a&nbsp;+&nbsp;n2b&nbsp;+&nbsp;n3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;b'&nbsp;=&nbsp;m1a&nbsp;+&nbsp;m2b&nbsp;+&nbsp;m3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;c'&nbsp;=&nbsp;o1a&nbsp;+&nbsp;o2b&nbsp;+&nbsp;o3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;[a',b',c']&nbsp;=&nbsp;P[a,b,c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;[[n1,n2,n3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[m1,m2,m3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[o1,o2,o3]]<br>
Returns&nbsp;a&nbsp;superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;xtl.generate_superstructrue([[2,0,0],[0,2,0],[0,0,1]])<br>
&nbsp;<br>
<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;classes&nbsp;have&nbsp;additional&nbsp;attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.P&nbsp;=&nbsp;P&nbsp;as&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.Parent&nbsp;=&nbsp;the&nbsp;parent&nbsp;<a href="#Crystal">Crystal</a>&nbsp;Class<br>
&nbsp;<br>
Use&nbsp;&gt;&gt;hasattr(su,'Parent')&nbsp;to&nbsp;check&nbsp;if&nbsp;the&nbsp;current&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;a<br>
superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class</tt></dd></dl>

<dl><dt><a name="Superstructure-info"><strong>info</strong></a>(self)</dt><dd><tt>Returns&nbsp;information&nbsp;about&nbsp;the&nbsp;crystal&nbsp;structure<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Superstructure-invert_structure"><strong>invert_structure</strong></a>(self)</dt><dd><tt>Convert&nbsp;handedness&nbsp;of&nbsp;structure,&nbsp;transform&nbsp;from&nbsp;left-handed&nbsp;to&nbsp;right&nbsp;handed,&nbsp;or&nbsp;visa-versa<br>
Equivlent&nbsp;to&nbsp;xtl.<a href="#Superstructure-transform">transform</a>([[-1,0,0],&nbsp;[0,-1,0],&nbsp;[0,0,-1]])<br>
:return:&nbsp;<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class</tt></dd></dl>

<dl><dt><a name="Superstructure-new_atoms"><strong>new_atoms</strong></a>(self, u=[0], v=[0], w=[0], type=None, label=None, occupancy=None, uiso=None, mxmymz=None)</dt><dd><tt>Replace&nbsp;current&nbsp;atomic&nbsp;positions&nbsp;with&nbsp;new&nbsp;ones&nbsp;and&nbsp;regenerate&nbsp;structure<br>
:param&nbsp;u:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;positions&nbsp;u<br>
:param&nbsp;v:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;positions&nbsp;v<br>
:param&nbsp;w:&nbsp;&nbsp;array&nbsp;:&nbsp;atomic&nbsp;positions&nbsp;w<br>
:param&nbsp;type:&nbsp;&nbsp;array&nbsp;:&nbsp;atomic&nbsp;types<br>
:param&nbsp;label:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;labels<br>
:param&nbsp;occupancy:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;occupation<br>
:param&nbsp;uiso:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;isotropic&nbsp;thermal&nbsp;parameters<br>
:param&nbsp;mxmymz:&nbsp;array&nbsp;:&nbsp;atomic&nbsp;magnetic&nbsp;vectors&nbsp;[mu,mv,mw]<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Superstructure-new_cell"><strong>new_cell</strong></a>(self, lattice_parameters=(), *args, **kwargs)</dt><dd><tt>Replace&nbsp;the&nbsp;lattice&nbsp;parameters<br>
:param&nbsp;lattice_parameters:&nbsp;[a,b,c,alpha,beta,gamma]<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Superstructure-start_gui"><strong>start_gui</strong></a>(self)</dt><dd><tt>Start&nbsp;<a href="#Crystal">Crystal</a>&nbsp;GUI<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Superstructure-transform"><strong>transform</strong></a>(self, P)</dt><dd><tt>Transform&nbsp;the&nbsp;current&nbsp;cell<br>
&nbsp;&nbsp;&nbsp;&nbsp;a'&nbsp;=&nbsp;n1a&nbsp;+&nbsp;n2b&nbsp;+&nbsp;n3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;b'&nbsp;=&nbsp;m1a&nbsp;+&nbsp;m2b&nbsp;+&nbsp;m3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;c'&nbsp;=&nbsp;o1a&nbsp;+&nbsp;o2b&nbsp;+&nbsp;o3c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;[a',b',c']&nbsp;=&nbsp;P[a,b,c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Where<br>
&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;[[n1,n2,n3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[m1,m2,m3],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[o1,o2,o3]]<br>
Returns&nbsp;a&nbsp;superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;=&nbsp;xtl.<a href="#Superstructure-transform">transform</a>([[0,1,0],[1,0,0],[0,0,1]])<br>
&nbsp;<br>
<a href="#Superstructure">Superstructure</a>&nbsp;<a href="#Crystal">Crystal</a>&nbsp;classes&nbsp;have&nbsp;additional&nbsp;attributes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.P&nbsp;=&nbsp;P&nbsp;as&nbsp;given<br>
&nbsp;&nbsp;&nbsp;&nbsp;su.Parent&nbsp;=&nbsp;the&nbsp;parent&nbsp;<a href="#Crystal">Crystal</a>&nbsp;Class<br>
&nbsp;<br>
Use&nbsp;&gt;&gt;hasattr(su,'Parent')&nbsp;to&nbsp;check&nbsp;if&nbsp;the&nbsp;current&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;a<br>
superstructure&nbsp;<a href="#Crystal">Crystal</a>&nbsp;class</tt></dd></dl>

<dl><dt><a name="Superstructure-update_cif"><strong>update_cif</strong></a>(self, cifvals=None)</dt><dd><tt>Update&nbsp;self.<strong>cif</strong>&nbsp;dict&nbsp;with&nbsp;current&nbsp;values<br>
:param&nbsp;cifvals:&nbsp;cif&nbsp;dict&nbsp;from&nbsp;readcif&nbsp;(None&nbsp;to&nbsp;use&nbsp;self.<strong>cif</strong>)<br>
:return:&nbsp;cifvals</tt></dd></dl>

<dl><dt><a name="Superstructure-write_cif"><strong>write_cif</strong></a>(self, filename=None, comments=None)</dt><dd><tt>Write&nbsp;crystal&nbsp;structure&nbsp;to&nbsp;CIF&nbsp;(Crystallographic&nbsp;Information&nbsp;File)<br>
&nbsp;Only&nbsp;basic&nbsp;information&nbsp;is&nbsp;saved&nbsp;to&nbsp;the&nbsp;file,&nbsp;but&nbsp;enough&nbsp;to&nbsp;open&nbsp;in&nbsp;VESTA&nbsp;etc.<br>
&nbsp;If&nbsp;magnetic&nbsp;ions&nbsp;are&nbsp;defined,&nbsp;a&nbsp;magnetic&nbsp;cif&nbsp;(*.mcif)&nbsp;will&nbsp;be&nbsp;produce<br>
:param&nbsp;filename:&nbsp;name&nbsp;to&nbsp;write&nbsp;too,&nbsp;if&nbsp;None,&nbsp;use&nbsp;writes&nbsp;to&nbsp;self.<strong>name</strong>&nbsp;(.cif/.mcif)<br>
:param&nbsp;comments:&nbsp;str&nbsp;comments&nbsp;to&nbsp;add&nbsp;to&nbsp;file&nbsp;header<br>
:return:&nbsp;None</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="Dans_Diffraction.classes_crystal.html#Crystal">Crystal</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="Dans_Diffraction.classes_crystal.html#Crystal">Crystal</a>:<br>
<dl><dt><strong>cif</strong> = {}</dl>

<dl><dt><strong>filename</strong> = ''</dl>

<dl><dt><strong>name</strong> = 'Crystal'</dl>

<dl><dt><strong>scale</strong> = 1.0</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Symmetry">class <strong>Symmetry</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Symmetry">Symmetry</a>(symmetry_operations=None,&nbsp;symmetry_operations_magnetic=None)<br>
&nbsp;<br>
Contains&nbsp;symmetry&nbsp;information&nbsp;about&nbsp;the&nbsp;crystal,&nbsp;including&nbsp;the&nbsp;symmetry&nbsp;operations.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Symmetry-__init__"><strong>__init__</strong></a>(self, symmetry_operations=None, symmetry_operations_magnetic=None)</dt><dd><tt>Initialises&nbsp;the&nbsp;symmetry&nbsp;group</tt></dd></dl>

<dl><dt><a name="Symmetry-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Symmetry-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Symmetry-addcen"><strong>addcen</strong></a>(self, operations, mag_operations=None)</dt><dd><tt>Apply&nbsp;centring&nbsp;operations&nbsp;to&nbsp;current&nbsp;symmetry&nbsp;operations</tt></dd></dl>

<dl><dt><a name="Symmetry-addsym"><strong>addsym</strong></a>(self, operations, mag_operations=None)</dt><dd><tt>Add&nbsp;symmetry&nbsp;operations<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-addsym">addsym</a>('x,y,z+1/2')&nbsp;&gt;&gt;&nbsp;adds&nbsp;single&nbsp;symmetry&nbsp;operation,&nbsp;magnetic&nbsp;operation&nbsp;is&nbsp;infered<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-addsym">addsym</a>(['x,y,z+1/2','z,x,y'])&nbsp;&gt;&gt;&nbsp;adds&nbsp;multiple&nbsp;symmetry&nbsp;operation,&nbsp;magnetic&nbsp;operations&nbsp;are&nbsp;infered<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-addsym">addsym</a>('x,y,z+1/2','x,y,-z')&nbsp;&gt;&gt;&nbsp;adds&nbsp;single&nbsp;symmetry&nbsp;operation&nbsp;+&nbsp;magnetic&nbsp;operation</tt></dd></dl>

<dl><dt><a name="Symmetry-average_symmetric_intensity"><strong>average_symmetric_intensity</strong></a>(self, hkl_list, intensity_list, tolerance=0.01)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;reflections&nbsp;with&nbsp;symmetric&nbsp;reflections&nbsp;removed,&nbsp;matching&nbsp;reflections&nbsp;will&nbsp;be&nbsp;averaged<br>
:param&nbsp;hkl_list:&nbsp;list&nbsp;of&nbsp;[h,k,l]&nbsp;reflections<br>
:param&nbsp;intensity_list:&nbsp;list&nbsp;of&nbsp;intensities<br>
:param&nbsp;tolerance:&nbsp;tolerance&nbsp;for&nbsp;matching&nbsp;reflections<br>
:return:&nbsp;array&nbsp;of&nbsp;[h,k,l]</tt></dd></dl>

<dl><dt><a name="Symmetry-axial_vector"><strong>axial_vector</strong></a>(self, uvw, remove_identical=True)</dt><dd><tt>Perform&nbsp;symmetry&nbsp;operations&nbsp;on&nbsp;an&nbsp;axial&nbsp;vector&nbsp;uvw<br>
:param&nbsp;uvw:&nbsp;3&nbsp;element&nbsp;array/&nbsp;list&nbsp;in&nbsp;cell&nbsp;coordinates<br>
:param&nbsp;remove_identical:&nbsp;True/&nbsp;False,&nbsp;if&nbsp;True,&nbsp;identical&nbsp;operations&nbsp;are&nbsp;removed<br>
:return:&nbsp;[S*3]&nbsp;&nbsp;array&nbsp;of&nbsp;transformed&nbsp;coordinates</tt></dd></dl>

<dl><dt><a name="Symmetry-changesym"><strong>changesym</strong></a>(self, idx, operation)</dt><dd><tt>Change&nbsp;a&nbsp;symmetry&nbsp;operation<br>
:param&nbsp;idx:&nbsp;symmetry&nbsp;index<br>
:param&nbsp;operation:&nbsp;str&nbsp;e.g.&nbsp;'x,-y,z'</tt></dd></dl>

<dl><dt><a name="Symmetry-fromcif"><strong>fromcif</strong></a>(self, cifvals)</dt><dd><tt>Import&nbsp;symmetry&nbsp;information&nbsp;from&nbsp;a&nbsp;cif&nbsp;dictionary<br>
Required&nbsp;cif&nbsp;keys:<br>
&nbsp;&nbsp;&nbsp;&nbsp;None<br>
Optional&nbsp;cif&nbsp;keys:<br>
&nbsp;&nbsp;&nbsp;&nbsp;_symmetry_equiv_pos_as_xyz<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_symop_operation_xyz<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_symop_magn_operation_xyz<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_symop_magn_operation_mxmymz<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_symop_magn_centering_xyz<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_symop_magn_centering_mxmymz<br>
&nbsp;&nbsp;&nbsp;&nbsp;_symmetry_space_group_name_H-M<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_name_H-M_alt<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_magn_name_BNS<br>
&nbsp;&nbsp;&nbsp;&nbsp;_symmetry_Int_Tables_number<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_IT_number<br>
&nbsp;&nbsp;&nbsp;&nbsp;_space_group_magn_number_BNS<br>
:param&nbsp;cifvals:&nbsp;dict&nbsp;of&nbsp;values&nbsp;from&nbsp;cif<br>
:return:</tt></dd></dl>

<dl><dt><a name="Symmetry-generate_matrices"><strong>generate_matrices</strong></a>(self)</dt><dd><tt>Generates&nbsp;the&nbsp;symmetry&nbsp;matrices&nbsp;from&nbsp;string&nbsp;symmetry&nbsp;operations</tt></dd></dl>

<dl><dt><a name="Symmetry-info"><strong>info</strong></a>(self)</dt><dd><tt>Prints&nbsp;the&nbsp;symmetry&nbsp;information<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Symmetry-invert_magsym"><strong>invert_magsym</strong></a>(self, idx)</dt><dd><tt>Invert&nbsp;the&nbsp;time&nbsp;symmetry&nbsp;of&nbsp;a&nbsp;magnetic&nbsp;symmetry<br>
:param&nbsp;idx:&nbsp;symmetry&nbsp;index,&nbsp;0:Nsym<br>
:return:</tt></dd></dl>

<dl><dt><a name="Symmetry-is_symmetric_reflection"><strong>is_symmetric_reflection</strong></a>(self, hkl1, hkl2, tolerance=0.01)</dt><dd><tt>Check&nbsp;if&nbsp;reflection&nbsp;1&nbsp;is&nbsp;a&nbsp;symmetric&nbsp;equivalent&nbsp;of&nbsp;reflection&nbsp;2<br>
:param&nbsp;hkl1:&nbsp;[h,k,l]&nbsp;reflection&nbsp;1<br>
:param&nbsp;hkl2:&nbsp;[h,k,l]&nbsp;reflection&nbsp;2<br>
:param&nbsp;tolerance:&nbsp;tolerance&nbsp;for&nbsp;matching&nbsp;reflections<br>
:return:&nbsp;True/&nbsp;False</tt></dd></dl>

<dl><dt><a name="Symmetry-load_magnetic_spacegroup"><strong>load_magnetic_spacegroup</strong></a>(self, msg_number)</dt><dd><tt>Load&nbsp;symmetry&nbsp;operations&nbsp;from&nbsp;a&nbsp;magnetic&nbsp;spacegroup&nbsp;from&nbsp;Bilbao&nbsp;crystallographic&nbsp;server<br>
Replaces&nbsp;the&nbsp;current&nbsp;symmetry&nbsp;operators&nbsp;and&nbsp;the&nbsp;magnetic&nbsp;symmetry&nbsp;operators.<br>
See&nbsp;functions_crystallography.spacegroup_magnetic&nbsp;for&nbsp;more&nbsp;details<br>
:param&nbsp;msg_number:&nbsp;magnetic&nbsp;space&nbsp;group&nbsp;number&nbsp;e.g.&nbsp;61.433<br>
:return:</tt></dd></dl>

<dl><dt><a name="Symmetry-load_spacegroup"><strong>load_spacegroup</strong></a>(self, sg_number)</dt><dd><tt>Load&nbsp;symmetry&nbsp;operations&nbsp;from&nbsp;a&nbsp;spacegroup&nbsp;from&nbsp;the&nbsp;International&nbsp;Tables&nbsp;of&nbsp;Crystallogrphy<br>
See&nbsp;functions_crystallography.spacegroup&nbsp;for&nbsp;more&nbsp;details<br>
:param&nbsp;sg_number:&nbsp;space&nbsp;group&nbsp;number&nbsp;(1-230)<br>
:return:&nbsp;None</tt></dd></dl>

<dl><dt><a name="Symmetry-parity_time_info"><strong>parity_time_info</strong></a>(self)</dt><dd><tt>Returns&nbsp;string&nbsp;of&nbsp;parity&nbsp;and&nbsp;time&nbsp;operations&nbsp;for&nbsp;symmetry&nbsp;operations<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Symmetry-print_magnetic_spacegroups"><strong>print_magnetic_spacegroups</strong></a>(self, sg_number=None)</dt><dd><tt>Return&nbsp;str&nbsp;of&nbsp;available&nbsp;magnetic&nbsp;spacegroups&nbsp;for&nbsp;this&nbsp;spacegroup<br>
:param&nbsp;sg_number:&nbsp;spacegroup&nbsp;number,&nbsp;None&nbsp;to&nbsp;use&nbsp;current&nbsp;one<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Symmetry-print_subgroups"><strong>print_subgroups</strong></a>(self, sg_number=None)</dt><dd><tt>Return&nbsp;str&nbsp;of&nbsp;subgroups&nbsp;of&nbsp;this&nbsp;spacegroup<br>
:param&nbsp;sg_number:&nbsp;spacegroup&nbsp;number,&nbsp;None&nbsp;to&nbsp;use&nbsp;current&nbsp;one<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Symmetry-print_symmetric_coordinate_operations"><strong>print_symmetric_coordinate_operations</strong></a>(self, UVW, remove_identical=True)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;symmetric&nbsp;operations&nbsp;for&nbsp;given&nbsp;position<br>
Uses&nbsp;fc.gen_sym_pos<br>
Returns&nbsp;list&nbsp;of&nbsp;identical&nbsp;symmetry&nbsp;operations,&nbsp;with&nbsp;identical&nbsp;positions&nbsp;removed<br>
All&nbsp;positions&nbsp;returned&nbsp;if&nbsp;remove_identical=False<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-print_symmetric_coordinate_operations">print_symmetric_coordinate_operations</a>([0.1,0,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;n&nbsp;&nbsp;u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>&nbsp;&nbsp;&nbsp;&nbsp;Magnetic&nbsp;<a href="#Symmetry">Symmetry</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0.1000&nbsp;&nbsp;0.0000&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,y,z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x,y,z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0.9000&nbsp;&nbsp;0.0000&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-x,-y,-z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-x,-y,-z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;0.1000&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,x,z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y,x,z</tt></dd></dl>

<dl><dt><a name="Symmetry-print_symmetric_vectors"><strong>print_symmetric_vectors</strong></a>(self, HKL)</dt><dd><tt>Print&nbsp;symmetric&nbsp;vectors<br>
:param&nbsp;HKL:&nbsp;[h,k,l]&nbsp;reflection<br>
:return:&nbsp;str</tt></dd></dl>

<dl><dt><a name="Symmetry-reflection_multiplyer"><strong>reflection_multiplyer</strong></a>(self, HKL)</dt><dd><tt>Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;symmetric&nbsp;reflections&nbsp;for&nbsp;each&nbsp;hkl<br>
:param&nbsp;HKL:&nbsp;[nx3]&nbsp;array&nbsp;of&nbsp;[h,k,l]<br>
:return:&nbsp;[n]&nbsp;array&nbsp;of&nbsp;multiplyers</tt></dd></dl>

<dl><dt><a name="Symmetry-remove_symmetric_reflections"><strong>remove_symmetric_reflections</strong></a>(self, hkl_list, tolerance=0.01)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;reflections&nbsp;with&nbsp;symmetric&nbsp;reflections&nbsp;removed<br>
:param&nbsp;hkl_list:&nbsp;list&nbsp;of&nbsp;[h,k,l]&nbsp;reflections<br>
:param&nbsp;tolerance:&nbsp;tolerance&nbsp;for&nbsp;matching&nbsp;reflections<br>
:return:&nbsp;array&nbsp;of&nbsp;[h,k,l]</tt></dd></dl>

<dl><dt><a name="Symmetry-spacegroup_name"><strong>spacegroup_name</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;spacegroup&nbsp;name&nbsp;and&nbsp;number&nbsp;as&nbsp;str</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_coordinate_operations"><strong>symmetric_coordinate_operations</strong></a>(self, UVW, MXMYMZ=None)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;symmetric&nbsp;operations&nbsp;for&nbsp;given&nbsp;position<br>
Uses&nbsp;fc.gen_sym_pos<br>
Returns&nbsp;list&nbsp;of&nbsp;identical&nbsp;symmetry&nbsp;operations,&nbsp;with&nbsp;identical&nbsp;positions&nbsp;removed.<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_coordinate_operations">symmetric_coordinate_operations</a>([0.1,0,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;array(['x,y,z',&nbsp;'-x,-y,-z',&nbsp;'y,x,z'])</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_coordinates"><strong>symmetric_coordinates</strong></a>(self, UVW, MXMYMZ=None, remove_identical=True)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;symmetric&nbsp;coordinates<br>
Uses&nbsp;fc.gen_sym_pos<br>
Returns&nbsp;coordinates&nbsp;wrapped&nbsp;within&nbsp;the&nbsp;unit&nbsp;cell,&nbsp;with&nbsp;identical&nbsp;positions&nbsp;removed.<br>
All&nbsp;positions&nbsp;returned&nbsp;if&nbsp;remove_identical=False<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_coordinates">symmetric_coordinates</a>([0.1,0,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;array([[0.1,&nbsp;0.0,&nbsp;0.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.9,&nbsp;0.0,&nbsp;0.0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.0,&nbsp;0.1,&nbsp;0.0]])</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_intensity"><strong>symmetric_intensity</strong></a>(self, HKL, I, dI=None)</dt><dd><tt>Returns&nbsp;symmetric&nbsp;reflections&nbsp;with&nbsp;summed&nbsp;intensities&nbsp;of&nbsp;repeated&nbsp;reflections<br>
Assumes&nbsp;HKL&nbsp;reflections&nbsp;are&nbsp;unique,&nbsp;repeated&nbsp;reflections&nbsp;will&nbsp;be&nbsp;incorrectly&nbsp;added&nbsp;together.<br>
Uses&nbsp;fc.gen_sym_mat<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.generate_matrixes()<br>
&nbsp;&nbsp;&nbsp;&nbsp;HKL,&nbsp;I&nbsp;=&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_intensity">symmetric_intensity</a>([1,1,0],10)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;HKL&nbsp;=&nbsp;array([[1,&nbsp;&nbsp;1,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1,-1,&nbsp;0]])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;I&nbsp;=&nbsp;array([20,10])<br>
&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;HKL,&nbsp;I,&nbsp;dI&nbsp;=&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_intensity">symmetric_intensity</a>([1,1,0],10,1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;HKL&nbsp;=&nbsp;array([[1,&nbsp;&nbsp;1,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1,-1,&nbsp;0]])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;I&nbsp;=&nbsp;array([20,10])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;dI&nbsp;=&nbsp;array([2,1])</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_magnetic_vectors"><strong>symmetric_magnetic_vectors</strong></a>(self, MXMYMZ)</dt><dd><tt>NOT&nbsp;COMPLETE</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_reflections"><strong>symmetric_reflections</strong></a>(self, HKL)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;symmetric&nbsp;reflection&nbsp;indices<br>
Uses&nbsp;fc.gen_sym_mat<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.generate_matrixes()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_reflections">symmetric_reflections</a>([1,0,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;array([[1,&nbsp;&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1,&nbsp;0,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0,&nbsp;-1,&nbsp;0]])</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_reflections_count"><strong>symmetric_reflections_count</strong></a>(self, HKL)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;symmetric&nbsp;reflection&nbsp;indices,<br>
identical&nbsp;reflections&nbsp;are&nbsp;removed,&nbsp;plus&nbsp;the&nbsp;counted&nbsp;sum&nbsp;of&nbsp;each&nbsp;reflection<br>
Uses&nbsp;fc.gen_sym_mat<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.generate_matrixes()<br>
&nbsp;&nbsp;&nbsp;&nbsp;HKL,&nbsp;count&nbsp;=&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_reflections">symmetric_reflections</a>([1,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;HKL&nbsp;=&nbsp;array([[1,&nbsp;&nbsp;1,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1,-1,&nbsp;0]])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;count&nbsp;=&nbsp;array([2,1])</tt></dd></dl>

<dl><dt><a name="Symmetry-symmetric_reflections_unique"><strong>symmetric_reflections_unique</strong></a>(self, HKL)</dt><dd><tt>Returns&nbsp;array&nbsp;of&nbsp;symmetric&nbsp;reflection&nbsp;indices,&nbsp;with&nbsp;identical&nbsp;reflections&nbsp;removed<br>
Uses&nbsp;fc.gen_sym_mat<br>
E.G.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.symmetry_operations&nbsp;=&nbsp;['x,y,z','-x,-y,-z','y,x,z']<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.generate_matrixes()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Symmetry">Symmetry</a>.<a href="#Symmetry-symmetric_reflections">symmetric_reflections</a>([1,1,0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;array([[1,&nbsp;&nbsp;1,&nbsp;0],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1,-1,&nbsp;0]])</tt></dd></dl>

<dl><dt><a name="Symmetry-update_cif"><strong>update_cif</strong></a>(self, cifvals)</dt><dd><tt>Update&nbsp;cifvals&nbsp;dict&nbsp;with&nbsp;current&nbsp;symmetry&nbsp;operations<br>
:param&nbsp;cifvals:&nbsp;cif&nbsp;dict&nbsp;from&nbsp;functions_crystallography.readcif<br>
:return:&nbsp;cifvals</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>spacegroup</strong> = 'P1'</dl>

<dl><dt><strong>spacegroup_number</strong> = 1</dl>

<dl><dt><strong>symmetry_matrices</strong> = array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])</dl>

<dl><dt><strong>symmetry_operations</strong> = ['x,y,z']</dl>

<dl><dt><strong>symmetry_operations_magnetic</strong> = ['x,y,z']</dl>

<dl><dt><strong>symmetry_operations_time</strong> = [1]</dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-warn"><strong>warn</strong></a>(message, category=None, stacklevel=1, source=None)</dt><dd><tt>Issue&nbsp;a&nbsp;warning,&nbsp;or&nbsp;maybe&nbsp;ignore&nbsp;it&nbsp;or&nbsp;raise&nbsp;an&nbsp;exception.</tt></dd></dl>
</td></tr></table>
</body></html>